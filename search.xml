<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot-15：富文本编辑器</title>
      <link href="/2022/05/30/SpringBoot-15%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2022/05/30/SpringBoot-15%EF%BC%9A%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-15：富文本编辑器"><a href="#SpringBoot-15：富文本编辑器" class="headerlink" title="SpringBoot-15：富文本编辑器"></a>SpringBoot-15：富文本编辑器</h1><h3 id="聊聊富文本编辑器"><a href="#聊聊富文本编辑器" class="headerlink" title="聊聊富文本编辑器"></a>聊聊富文本编辑器</h3><p> 思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的 吗？</p><p> 在博客园后台的选项设置中，可以看到一个文本编辑器的选项： </p><p><img src="https://s1.ax1x.com/2022/07/07/jwETrF.png" alt="1657077344574"></p><p> 其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如：  </p><ul><li><p>Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费 </p><p> 官网：<a href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a> </p></li><li><p> wangEditor——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源 免费。 </p></li></ul><p>  官网：<a href="http://www.wangeditor.com/">http://www.wangeditor.com/</a> </p><ul><li><p>TinyMCE——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对 IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文 水平有一定要求。</p><p> 官网：<a href="https://www.tiny.cloud/docs/demo/full-featured/">https://www.tiny.cloud/docs/demo/full-featured/</a> </p><p> 博客园  </p></li><li><p> 百度ueditor——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能 齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有 更新了 官网：<a href="https://ueditor.baidu.com/website/onlinedemo.html">https://ueditor.baidu.com/website/onlinedemo.html</a> </p></li><li><p>kindeditor——界面经典。 官网：<a href="http://kindeditor.net/demo.php">http://kindeditor.net/demo.php</a></p></li><li><p> Textbox——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包 含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助 技术，并符合WAI-ARIA可访问性标准。 官网：<a href="https://textbox.io/">https://textbox.io/</a> </p></li><li><p>CKEditor——国外的，界面美观。 官网：<a href="https://ckeditor.com/ckeditor-5/demo/">https://ckeditor.com/ckeditor-5/demo/</a></p></li><li><p>quill——功能强大，还可以编辑公式等 官网：<a href="https://quilljs.com/">https://quilljs.com/</a> </p></li><li><p>simditor——界面美观，功能较全。 官网：<a href="https://simditor.tower.im/">https://simditor.tower.im/</a> summernote——UI好看，精美 官网：<a href="https://summernote.org/">https://summernote.org/</a> </p></li><li><p>jodit——功能齐全 官网：<a href="https://xdsoft.net/jodit/">https://xdsoft.net/jodit/</a> </p></li><li><p>froala Editor——界面非常好看，功能非常强大，非常好用（非免费） 官网：<a href="https://www.froala.com/wysiwyg-editor">https://www.froala.com/wysiwyg-editor</a> </p><p>总之，目前可用的富文本编辑器有很多……这只是其中的一部分 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-14：异步、定时、邮件任务</title>
      <link href="/2022/05/30/SpringBoot-14%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%9A%E6%97%B6%E3%80%81%E9%82%AE%E4%BB%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/05/30/SpringBoot-14%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%9A%E6%97%B6%E3%80%81%E9%82%AE%E4%BB%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-14：异步、定时、邮件任务"><a href="#SpringBoot-14：异步、定时、邮件任务" class="headerlink" title="SpringBoot-14：异步、定时、邮件任务"></a>SpringBoot-14：异步、定时、邮件任务</h1><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>1、创建一个service包 </p><p>2、创建一个类AsyncService 异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直 到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。 </p><p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AsyncService &#123;</span><br><span class="line">public void hello()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、编写controller包 </p><p>4、编写AsyncController类 </p><p>我们去写一个Controller测试一下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class AsyncController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">AsyncService asyncService;</span><br><span class="line">@GetMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello()&#123;</span><br><span class="line">asyncService.hello();</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5、访问<a href="http://localhost:8080/hello%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C3%E7%A7%92%E5%90%8E%E5%87%BA%E7%8E%B0success%EF%BC%8C%E8%BF%99%E6%98%AF%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a> 问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手 动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解 即可，如下： </p><p>6、给hello方法添加@Async注解； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//告诉Spring这是一个异步方法</span><br><span class="line">@Async</span><br><span class="line">public void hello()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;业务进行中....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注 解@EnableAsync ，开启异步注解功能； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 7、重启测试，网页瞬间响应，后台代码依旧执行！  </p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p> 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring 为我们提供了异步执行任务调度的方式，提供了两个接口。 </p><ul><li> TaskExecutor接口 </li><li>TaskScheduler接口  </li></ul><p> 两个注解：  </p><ul><li> @EnableScheduling</li><li> @Scheduled  </li></ul><p> cron表达式： </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE7b4.png" alt="1657077071244"></p><p> 测试步骤： </p><p> 1、创建一个ScheduledService</p><p> 我们里面存在一个hello方法，他需要定时执行，怎么处理呢？ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ScheduledService &#123;</span><br><span class="line">//秒 分 时 日 月 周几</span><br><span class="line">//0 * * * * MON-FRI</span><br><span class="line">//注意cron表达式的用法；</span><br><span class="line">@Scheduled(cron = &quot;0 * * * * 0-7&quot;)</span><br><span class="line">public void hello()&#123;</span><br><span class="line">System.out.println(&quot;hello.....&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableAsync //开启异步注解功能</span><br><span class="line">@EnableScheduling //开启基于注解的定时任务</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootTaskApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(SpringbootTaskApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、我们来详细了解下cron表达式；</p><p> <a href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a> </p><p> 4、常用的表达式 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）0/2 * * * * ? 表示每2秒 执行任务</span><br><span class="line">（1）0 0/2 * * * ? 表示每2分钟 执行任务</span><br><span class="line">（1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务</span><br><span class="line">（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业</span><br><span class="line">（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作</span><br><span class="line">（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点</span><br><span class="line">（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时</span><br><span class="line">（6）0 0 12 ? * WED 表示每个星期三中午12点</span><br><span class="line">（7）0 0 12 * * ? 每天中午12点触发</span><br><span class="line">（8）0 15 10 ? * * 每天上午10:15触发</span><br><span class="line">（9）0 15 10 * * ? 每天上午10:15触发</span><br><span class="line">（10）0 15 10 * * ? 每天上午10:15触发</span><br><span class="line">（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发</span><br><span class="line">（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line">（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发</span><br><span class="line">（18）0 15 10 15 * ? 每月15日上午10:15触发</span><br><span class="line">（19）0 15 10 L * ? 每月最后一日的上午10:15触发</span><br><span class="line">（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发</span><br><span class="line">（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure><h3 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h3><p> 邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持 </p><ul><li> 邮件发送需要引入</li><li>spring-boot-start-mail SpringBoot 自动配置MailSenderAutoConfiguration</li><li> 定义MailProperties内容，配置在application.yml中</li><li> 自动装配JavaMailSender</li><li> 测试邮件发送 </li></ul><p> 测试：</p><p> 1、引入pom依赖  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 看它引入的依赖，可以看到 jakarta.mail </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.sun.mail&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.6.4&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 2、查看自动配置类：MailSenderAutoConfiguration </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEoKU.png" alt="1657077200052"></p><p> 这个类中存在bean，JavaMailSenderImpl  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEbVJ.png" alt="1657077212383"></p><p> 然后我们去看下配置文件  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">prefix = &quot;spring.mail&quot;</span><br><span class="line">)</span><br><span class="line">public class MailProperties &#123;</span><br><span class="line">private static final Charset DEFAULT_CHARSET;</span><br><span class="line">private String host;</span><br><span class="line">private Integer port;</span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">private String protocol = &quot;smtp&quot;;</span><br><span class="line">private Charset defaultEncoding;</span><br><span class="line">private Map&lt;String, String&gt; properties;</span><br><span class="line">private String jndiName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、配置文件： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.mail.username=24736743@qq.com</span><br><span class="line">spring.mail.password=你的qq授权码</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line"># qq需要配置ssl</span><br><span class="line">spring.mail.properties.mail.smtp.ssl.enable=true</span><br></pre></td></tr></table></figure><p> 获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEqa9.png" alt="1657077250731"></p><p> 4、Spring单元测试 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line">@Test</span><br><span class="line">public void contextLoads() &#123;</span><br><span class="line">//邮件设置1：一个简单的邮件</span><br><span class="line">SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">message.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">message.setText(&quot;今晚7:30开会&quot;);</span><br><span class="line">message.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">message.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line">mailSender.send(message);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void contextLoads2() throws MessagingException &#123;</span><br><span class="line">//邮件设置2：一个复杂的邮件</span><br><span class="line">MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);</span><br><span class="line">helper.setSubject(&quot;通知-明天来狂神这听课&quot;);</span><br><span class="line">helper.setText(&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;,true);</span><br><span class="line">//发送附件</span><br><span class="line">helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line">helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));</span><br><span class="line">helper.setTo(&quot;24736743@qq.com&quot;);</span><br><span class="line">helper.setFrom(&quot;24736743@qq.com&quot;);</span><br><span class="line">mailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 查看邮箱，邮件接收成功！</p><p> 我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！ </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-13：集成Swagger终极版</title>
      <link href="/2022/05/30/SpringBoot-13%EF%BC%9A%E9%9B%86%E6%88%90Swagger%E7%BB%88%E6%9E%81%E7%89%88/"/>
      <url>/2022/05/30/SpringBoot-13%EF%BC%9A%E9%9B%86%E6%88%90Swagger%E7%BB%88%E6%9E%81%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-13：集成Swagger终极版"><a href="#SpringBoot-13：集成Swagger终极版" class="headerlink" title="SpringBoot-13：集成Swagger终极版"></a>SpringBoot-13：集成Swagger终极版</h1><h3 id="项目集成Swagger"><a href="#项目集成Swagger" class="headerlink" title="项目集成Swagger"></a>项目集成Swagger</h3><p> 学习目标： </p><ul><li> 了解Swagger的概念及作用 </li><li>掌握在项目中集成Swagger自动生成API文档 </li></ul><h3 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h3><p> 前后端分离 </p><ul><li> 前端 -&gt; 前端控制层、视图层 </li><li>后端 -&gt; 后端控制层、服务层、数据访问层 </li><li>前后端通过API进行交互 </li><li>前后端相对独立且松耦合 </li></ul><p> 产生的问题  </p><ul><li> 前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发 </li></ul><p> 解决方案 </p><ul><li> 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险 </li></ul><p> Swagger </p><ul><li> 号称世界上最流行的API框架 </li><li>Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 </li><li>直接运行，在线测试API </li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a>  </li></ul><h4 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h4><p> SpringBoot集成Swagger =&gt; springfox，两个jar包 </p><ul><li> Springfox-swagger2 </li><li>swagger-springmvc  </li></ul><p> 使用Swagger </p><p> 要求：jdk 1.8 + 否则swagger2无法运行 </p><p>步骤： </p><p> 1、新建一个SpringBoot-web项目 </p><p>2、添加Maven依赖 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 3、编写HelloController，测试确保运行成功！ </p><p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration //配置类</span><br><span class="line">@EnableSwagger2// 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面； </p><p><img src="https://s1.ax1x.com/2022/07/07/jwER5n.png" alt="1657033133015"></p><h3 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h3><p> 1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean //配置docket以配置Swagger具体参数</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、可以通过apiInfo()属性配置文档信息 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置文档信息</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮</span><br><span class="line">箱&quot;);</span><br><span class="line">return new ApiInfo(</span><br><span class="line">&quot;Swagger学习&quot;, // 标题</span><br><span class="line">&quot;学习演示如何配置Swagger&quot;, // 描述</span><br><span class="line">&quot;v1.0&quot;, // 版本</span><br><span class="line">&quot;http://terms.service.url/组织链接&quot;, // 组织链接</span><br><span class="line">contact, // 联系人信息</span><br><span class="line">&quot;Apach 2.0 许可&quot;, // 许可</span><br><span class="line">&quot;许可链接&quot;, // 许可连接</span><br><span class="line">new ArrayList&lt;&gt;()// 扩展</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、Docket 实例关联上 apiInfo()  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> 看下效果； </p><h4 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h4><p> 1、构建Docket时通过select()方法配置怎么扫描接口。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(apiInfo())</span><br><span class="line">.select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 </p><p> 3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 扫描所有，项目中的所有接口都会被扫描到</span><br><span class="line">none() // 不扫描接口</span><br><span class="line">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span><br><span class="line">withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span><br><span class="line">withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line">basePackage(final String basePackage) // 根据包路径扫描接口</span><br></pre></td></tr></table></figure><p> 4、除此之外，我们还可以配置接口扫描过滤：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(apiInfo())</span><br><span class="line">.select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">.paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5、这里的可选值还有 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any() // 任何请求都扫描</span><br><span class="line">none() // 任何请求都不扫描</span><br><span class="line">regex(final String pathRegex) // 通过正则表达式控制</span><br><span class="line">ant(final String antPattern) // 通过ant()控制</span><br></pre></td></tr></table></figure><h4 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h4><p> 1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(apiInfo())</span><br><span class="line">.enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">.select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">.paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">// 设置要显示swagger的环境</span><br><span class="line">Profiles of = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span><br><span class="line">// 判断当前是否处于该环境</span><br><span class="line">// 通过 enable() 接收此参数判断是否要显示</span><br><span class="line">boolean b = environment.acceptsProfiles(of);</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.apiInfo(apiInfo())</span><br><span class="line">.enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问</span><br><span class="line">.select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span><br><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))</span><br><span class="line">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span><br><span class="line">.paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、可以在项目中增加一个dev的配置文件查看效果！  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE5vT.png" alt="1657033634243"></p><p> 1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket(Environment environment) &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">.groupName(&quot;hello&quot;) // 配置分组</span><br><span class="line">// 省略配置....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、重启项目查看分组 </p><p> 3、如何配置多个分组？配置多个分组只需要配置多个docket即可： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket docket1()&#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket2()&#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public Docket docket3()&#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 4、重启项目查看即可  </p><h4 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h4><p> 1、新建一个实体类 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">@ApiModelProperty(&quot;用户名&quot;)</span><br><span class="line">public String username;</span><br><span class="line">@ApiModelProperty(&quot;密码&quot;)</span><br><span class="line">public String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、重启查看测试 </p><p> 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会 显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 </p><p>@ApiModel为类添加注释 </p><p>@ApiModelProperty为类属性添加注释 </p><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p> Swagger的所有注解定义在io.swagger.annotations包下 </p><p> 下面列一些经常用到的，未列举出来的可以另行查阅说明：  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE42V.png" alt="1657033739240"></p><p> 我们也可以给请求的接口配置一些注释 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;狂神的接口&quot;)</span><br><span class="line">@PostMapping(&quot;/kuang&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;</span><br><span class="line">return username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ </p><p> 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得 好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基 本就不需要人为操作了。 </p><p> Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出 Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环 境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 </p><h4 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h4><p> 我们可以导入不同的包实现不同的皮肤定义： </p><p>1、默认的 访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 2、bootstrap-ui 访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 3、Layui-ui 访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 4、mg-ui 访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.zyplayer&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-12：MVC自动配置原理</title>
      <link href="/2022/05/30/SpringBoot-12%EF%BC%9AMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/30/SpringBoot-12%EF%BC%9AMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-12：MVC自动配置原理"><a href="#SpringBoot-12：MVC自动配置原理" class="headerlink" title="SpringBoot-12：MVC自动配置原理"></a>SpringBoot-12：MVC自动配置原理</h1><h3 id="MVC自动配置原理"><a href="#MVC自动配置原理" class="headerlink" title="MVC自动配置原理"></a>MVC自动配置原理</h3><p> 在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括 如何扩展，如何定制。 </p><p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p><p> 地址 ：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mv">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mv</a> c-auto-configuration  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring MVC Auto-configuration</span><br><span class="line">// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for </span><br><span class="line">Spring MVC that works well with most applications.</span><br><span class="line">// 自动配置在Spring默认设置的基础上添加了以下功能：</span><br><span class="line">The auto-configuration adds the following features on top of Spring’s defaults:</span><br><span class="line">// 包含视图解析器Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</span><br><span class="line">// 支持静态资源文件夹的路径，以及webjarsSupport for serving static resources, including support for WebJars </span><br><span class="line">// 自动注册了Converter：</span><br><span class="line">// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int 类型</span><br><span class="line">// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date</span><br><span class="line">对象】Automatic registration of Converter, GenericConverter, and Formatter beans.</span><br><span class="line">// HttpMessageConverters</span><br><span class="line">// SpringMVC用来转换Http请求和响应的的，比如我们要把一个</span><br><span class="line">User对象转换为JSON字符串，可以去看官网文档解释；Support for HttpMessageConverters (covered later in this document).</span><br><span class="line">// 定义错误代码生成规则的Automatic registration of MessageCodesResolver (covered later in this document).</span><br><span class="line">// 首页定制Static index.html support.</span><br><span class="line">// 图标定制Custom Favicon support (covered later in this doc</span><br><span class="line">ument).</span><br><span class="line">// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！Automatic use of a Con</span><br><span class="line">figurableWebBindingInitializer bean (covered later in this document).</span><br><span class="line">/*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控</span><br><span class="line">制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAda</span><br><span class="line">pter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistratio</span><br><span class="line">nAdapter实例来提供此类组件。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class</span><br><span class="line">of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide</span><br><span class="line">custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdap</span><br><span class="line">ter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistra</span><br><span class="line">tionsAdapter instance to provide such components.</span><br><span class="line">// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own</span><br><span class="line">@Configuration annotated with @EnableWebMvc.</span><br><span class="line">我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</span><br></pre></td></tr></table></figure><h4 id="ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="ContentNegotiatingViewResolver 内容协商视图解析器"></a>ContentNegotiatingViewResolver 内容协商视图解析器</h4><p> 自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； </p><p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 </p><p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索 ContentNegotiatingViewResolver。找到如下方法！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConditionalOnBean(ViewResolver.class)</span><br><span class="line">@ConditionalOnMissingBean(name =</span><br><span class="line">&quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)</span><br><span class="line">public Content NegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();</span><br><span class="line">resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); </span><br><span class="line">// ContentNegotiatingViewResolver使用所有其他视图解析器来定</span><br><span class="line">位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE</span><br><span class="line">); return resolver;&#125;</span><br><span class="line"></span><br><span class="line">@Nullable </span><br><span class="line">// 注解说明：@Nullable 即参数可为nullpublic View resolveViewName(Stri</span><br><span class="line">ng viewName, Locale locale) throws Exception &#123; RequestAttributes attrs =</span><br><span class="line">RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanc</span><br><span class="line">eof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); Li</span><br><span class="line">st&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttr</span><br><span class="line">ibutes)attrs).getRequest()); if (requestedMediaTypes != null) &#123; </span><br><span class="line">// 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(</span><br><span class="line">viewName, locale, requestedMediaTypes); </span><br><span class="line">// 选择一个最适合的视图对象，然后把这个对象返回 </span><br><span class="line">View bestView = this.getBestView(candidateViews, request</span><br><span class="line">edMediaTypes, attrs); if (bestView != null) &#123; </span><br><span class="line">return best View; &#125; &#125; </span><br><span class="line">// .....&#125;</span><br></pre></td></tr></table></figure><p> 我们继续点进去看，他是怎么获得候选的视图的呢？ </p><p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ </p><p> Iterator var5 = this.viewResolvers.iterator(); </p><p> 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器 的 </p><p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void initServletContext(ServletContext servletContext) &#123; // 这</span><br><span class="line">里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有</span><br><span class="line">的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUti</span><br><span class="line">ls.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResol</span><br><span class="line">ver.class).values(); ViewResolver viewResolver; if (this.viewResolver</span><br><span class="line">s == null) &#123; this.viewResolvers = new ArrayList(matchingBeans.size()</span><br><span class="line">); &#125; // ...............&#125;</span><br></pre></td></tr></table></figure><p> 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ </p><p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下  </p><p> 1、我们在我们的主程序中去写一个视图解析器来试试； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean </span><br><span class="line">//放到bean中public ViewResolver myViewResolver()&#123; return new MyView</span><br><span class="line">Resolver();&#125;</span><br><span class="line">//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口private static class MyViewResolver implements ViewResolver&#123; @Override public View resolveVie</span><br><span class="line">wName(String s, Locale locale) throws Exception &#123; return null; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 2、怎么看我们自己写的视图解析器有没有起作用呢？ </p><p> 我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法 中  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEwCt.png" alt="1657031639889"></p><p> 3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； </p><p> 找到this </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEyDg.png" alt="1657031653633"></p><p> 找到视图解析器，我们看到我们自己定义的就在这里了；  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEgEj.png" alt="1657031665442"></p><p> 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情 SpringBoot就会帮我们做了！ </p><h4 id="转换器和格式化器"><a href="#转换器和格式化器" class="headerlink" title="转换器和格式化器"></a>转换器和格式化器</h4><p> 找到格式化转换器：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Override</span><br><span class="line">public FormattingConversionService mvcConversionService() &#123;</span><br><span class="line">// 拿到配置文件中的格式化规则 </span><br><span class="line">WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); </span><br><span class="line">addFormatters(conversionService); return conversionService;&#125;</span><br></pre></td></tr></table></figure><p> 点击去： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String getDateFormat() &#123; return this.dateFormat;&#125;</span><br><span class="line">/*** Date format to use. For instance, `dd/MM/yyyy`. 默认的 */</span><br><span class="line">private String dateFormat;</span><br></pre></td></tr></table></figure><p> 可以看到在我们的Properties文件中，我们可以进行自动配置它！ </p><p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE2Us.png" alt="1657031922601"></p><p> 其余的就不一一举例了，大家可以下去多研究探讨即可！  </p><h4 id="修改SpringBoot的默认配置"><a href="#修改SpringBoot的默认配置" class="headerlink" title="修改SpringBoot的默认配置"></a>修改SpringBoot的默认配置</h4><p> 这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方 式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 </p><p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； </p><p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean）， 如果有就用用户配置的，如果没有就用自动配置的； </p><p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ </p><p>扩展使用SpringMVC 官方文档如下： </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE6bQ.png" alt="1657031973003"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//应为类型要求为WebMvcConfigurer，所以我们实现其接口</span><br><span class="line">//可以使用自定义类扩展MVC的功能</span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">@Override </span><br><span class="line">public void addViewControllers(ViewControllerRegistry registry) &#123; </span><br><span class="line">// 浏览器发送/test ， 就会跳转到test页面； </span><br><span class="line">registry.addView</span><br><span class="line">Controller(&quot;/test&quot;).setViewName(&quot;test&quot;); &#125;&#125;</span><br></pre></td></tr></table></figure><p> 我们去浏览器访问一下：  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEh80.png" alt="1657032016751"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSuppo</span><br><span class="line">rt &#123; private final WebMvcConfigurerComposite configurers = new WebMvcCon</span><br><span class="line">figurerComposite(); </span><br><span class="line">// 从容器中获取所有的webmvcConfigurer </span><br><span class="line">@Autowired(required = false) </span><br><span class="line">public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void addViewControllers(ViewControllerRegistry registry) &#123; this</span><br><span class="line">.configurers.addViewControllers(registry);&#125;</span><br></pre></td></tr></table></figure><p> 5、我们点进去看一下  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void addViewControllers(ViewControllerRegistry registry) &#123; </span><br><span class="line">Iterator var2 = this.delegates.iterator();</span><br><span class="line">while(var2.hasNext()) &#123; </span><br><span class="line">// 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 </span><br><span class="line">WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当 然也会被调用； </p><h4 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h4><p> 官方文档： </p><p> If you want to take complete control of Spring MVCyou can add your own @Con figuration annotated with @EnableWebMvc.  </p><p> 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p><p> 只需在我们的配置类中要加一个@EnableWebMvc。 </p><p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效， 我们可以去测试一下； </p><p>不加注解之前，访问首页： </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEfCq.png" alt="1657032293553"></p><p> 我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子； 当然，我们开发中，不推荐使用全面接管SpringMVC </p><p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：  </p><p> 1、这里发现它是导入了一个类，我们可以继续进去看 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMv</span><br><span class="line">c &#123;&#125;</span><br></pre></td></tr></table></figure><p> 2、它继承了一个父类 WebMvcConfigurationSupport </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSuppo</span><br><span class="line">rt &#123; // ......&#125;</span><br></pre></td></tr></table></figure><p> 3、我们来回顾一下Webmvc自动配置类  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type =</span><br><span class="line">Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="line">WebMvcConfigurer.class &#125;)// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置</span><br><span class="line">类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfi</span><br><span class="line">gureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherS</span><br><span class="line">ervletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, Val</span><br><span class="line">idationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; &#125;</span><br></pre></td></tr></table></figure><p> 总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了； </p><p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！ </p><p>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-11：Thymeleaf模板引擎</title>
      <link href="/2022/05/30/SpringBoot-11%EF%BC%9AThymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2022/05/30/SpringBoot-11%EF%BC%9AThymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-11：Thymeleaf模板引擎"><a href="#SpringBoot-11：Thymeleaf模板引擎" class="headerlink" title="SpringBoot-11：Thymeleaf模板引擎"></a>SpringBoot-11：Thymeleaf模板引擎</h1><h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p> 前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我 们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p><p> jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是 以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。</p><p> 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p><p> SpringBoot推荐你可以来使用模板引擎：</p><p> 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括 SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什 么样一个思想呢我们来看一下这张图：  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwE08P.png" alt="1657029841768"></p><p> 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从 哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们 这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我 们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不 同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我 们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且 呢，功能更强大。</p><p> 我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 </p><h4 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h4><p> 怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家 三个网址：  </p><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> </p><p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a> </p><p>Spring官方文档：找到我们对应的版本 </p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> 找到对应的pom依赖：可以适当点进源码看下本来的包！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--thymeleaf--&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> Maven会自动下载jar包，我们可以去看下下载的东西； </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEDv8.png" alt="1657029906038"></p><h4 id="Thymeleaf分析"><a href="#Thymeleaf分析" class="headerlink" title="Thymeleaf分析"></a>Thymeleaf分析</h4><p> 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ </p><p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则， 我们进行使用。 </p><p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties( prefix = &quot;spring.thymeleaf&quot;)</span><br><span class="line">public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; </span><br><span class="line">public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; </span><br><span class="line">public static final String DEFAULT_SUFFIX = &quot;.html&quot;; </span><br><span class="line">private boolean checkTemplate = true; </span><br><span class="line">private boolean checkTemplateLocation = true; </span><br><span class="line">private String prefix = &quot;classpath:/templates/&quot;; private String suffix = &quot;.html&quot;; </span><br><span class="line">private String mode = &quot;HTML&quot;; private Charset encoding;&#125;</span><br></pre></td></tr></table></figure><p> 我们可以在其中看到默认的前缀和后缀！ </p><p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 </p><p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ </p><p> <strong>测试</strong> </p><p> 1、编写一个TestController  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controllerpublic class TestController &#123; </span><br><span class="line">@RequestMapping(&quot;/t1&quot;) </span><br><span class="line">public String test1()&#123; </span><br><span class="line">//classpath:/templates/test.html </span><br><span class="line">return &quot;test&quot;; &#125; &#125;</span><br></pre></td></tr></table></figure><p> 2、编写一个测试页面 test.html 放在 templates 目录下  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;T</span><br><span class="line">itle&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> 3、启动项目请求测试 </p><h4 id="Thymeleaf-语法学习"><a href="#Thymeleaf-语法学习" class="headerlink" title="Thymeleaf 语法学习"></a>Thymeleaf 语法学习</h4><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； </p><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ </p><p>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示 </p><p> 1、修改测试请求，增加数据传输； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/t1&quot;)</span><br><span class="line">public String test1(Model model)&#123; </span><br><span class="line">//存入数据 </span><br><span class="line">model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;); //classpath:/templates/test.html</span><br><span class="line">return &quot;test&quot;;&#125;</span><br></pre></td></tr></table></figure><p> 2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。 我们可以去官方文档的#3中看一下命名空间拿来过来： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure><p> 3、我们去编写下前端页面  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;狂神说&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;</span><br><span class="line">&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> 4、启动测试！ </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEBgf.png" alt="1657030587954"></p><p> OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！ </p><p>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！  </p><p><img src="https://s1.ax1x.com/2022/07/07/jwEsKS.png" alt="1657030608693"></p><p> 2、我们能写哪些表达式呢？  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Simple expressions:（表达式语法）Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；</span><br><span class="line">1）、获取对象的属性、调用方法 </span><br><span class="line">2）、使用内置的基本对象：</span><br><span class="line">#18 </span><br><span class="line">#ctx : the context object. </span><br><span class="line">#vars: the context variables. #locale : the context locale. </span><br><span class="line">#request : (only in Web Contexts) the HttpServletRequest object. </span><br><span class="line">#response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. </span><br><span class="line">#servletContext : (only in Web Contexts) the ServletContext object.</span><br><span class="line">3）、内置的一些工具对象： </span><br><span class="line">#execInfo : information about the template being processed. </span><br><span class="line">#uris : methods for escaping parts of URLs/URIs</span><br><span class="line">#conversions : methods for executing the configured conversion se</span><br><span class="line">rvice (if any). #dates : methods for java.util.Date objects: forma</span><br><span class="line">tting, component extraction, etc. #calendars : analogous to </span><br><span class="line">#dates, but for java.util.Calendar objects. </span><br><span class="line">#numbers : methods for form atting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation.</span><br><span class="line">#arrays : methods for arrays. #lists : methods for lists.</span><br><span class="line">#sets : methods for sets. #maps : methods for maps.</span><br><span class="line">#aggregates : methods for creating aggregates on arrays or collections.====</span><br><span class="line">Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； Mess</span><br><span class="line">age Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL；</span><br><span class="line">Fragment Expressions: ~&#123;...&#125;：片段引用表达式</span><br><span class="line">Literals（字面量） Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,… Nu</span><br><span class="line">mber literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false</span><br><span class="line">Null literal: null Literal tokens: one , sometext , main ,… T</span><br><span class="line">ext operations:（文本操作） String concatenation: + Literal substitutio</span><br><span class="line">ns: |The name is $&#123;name&#125;| Arithmetic operations:（数学运算） Binary ope</span><br><span class="line">rators: + , - , * , / , % Minus sign (unary operator): - Boolean oper</span><br><span class="line">ations:（布尔运算） Binary operators: and , or Boolean negation (unary</span><br><span class="line">operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt;</span><br><span class="line">, &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq ,</span><br><span class="line">ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then)</span><br><span class="line">If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalu</span><br><span class="line">e) Special tokens: No-Operation: _</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-10：Web开发静态资源处理</title>
      <link href="/2022/05/29/SpringBoot-10%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/29/SpringBoot-10%EF%BC%9AWeb%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-10：Web开发静态资源处理"><a href="#SpringBoot-10：Web开发静态资源处理" class="headerlink" title="SpringBoot-10：Web开发静态资源处理"></a>SpringBoot-10：Web开发静态资源处理</h1><h3 id="Web开发探究"><a href="#Web开发探究" class="headerlink" title="Web开发探究"></a>Web开发探究</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p> 好的，同学们，那么接下来呢，我们开始学习SpringBoot与Web开发，从这一章往后，就属于我们实战部分 的内容了； </p><p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。 使用SpringBoot的步骤： </p><p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好 </p><p>2、手动在配置文件中配置部分配置项目就可以运行起来了 </p><p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p><p> 比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？ </p><ul><li>向容器中自动配置组件 ：Autoconfiguration </li><li>自动配置类，封装配置文件的内容：Properties </li></ul><p>没事就找找类，看看自动装配原理！ 我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！ </p><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><h4 id="静态资源映射规则"><a href="#静态资源映射规则" class="headerlink" title="静态资源映射规则"></a>静态资源映射规则</h4><p> 首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！ </p><p> 写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个 SpringBoot怎么处理呢？ </p><p> 如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对 吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？ 当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！ 我们先来聊聊这个静态资源映射规则： </p><p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 有一个方法：addResourceHandlers 添加资源处理 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">if (!this.resourceProperties.isAddMappings()) &#123; </span><br><span class="line">// 已禁用默认资源处理</span><br><span class="line">logger.debug(&quot;Default resource handling disabled&quot;); return;</span><br><span class="line">&#125; </span><br><span class="line">// 缓存控制 </span><br><span class="line">Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 </span><br><span class="line">if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; </span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META-INF/reso</span><br><span class="line">urces/webjars/&quot;) .setCachePerio</span><br><span class="line">d(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; </span><br><span class="line">// 静态资源配置 </span><br><span class="line">String staticPathPattern = this.mvcProperties.getStaticPathPattern</span><br><span class="line">(); </span><br><span class="line">if (!registry.hasMappingForPattern(staticPathPattern)) &#123; </span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125;</span><br></pre></td></tr></table></figure><p> 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资 源； </p><h4 id="什么是webjars-呢？"><a href="#什么是webjars-呢？" class="headerlink" title="什么是webjars 呢？"></a>什么是webjars 呢？</h4><p> Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 使用SpringBoot需要使用Webjars，我们可以去搜索一下： </p><p> 网站：<a href="https://www.webjars.org/">https://www.webjars.org</a> 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.webjars&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;jquery&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;3.4.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 导入完毕，查看webjars目录结构，并访问Jquery.js文件！ </p><p><img src="https://s1.ax1x.com/2022/07/06/jULEZQ.png" alt="1657028344927"></p><p> 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，</p><p>我们这里访 问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a>  </p><p><img src="https://s1.ax1x.com/2022/07/06/jULkqg.png" alt="1657028401803"></p><h4 id="第二种静态资源映射规则"><a href="#第二种静态资源映射规则" class="headerlink" title="第二种静态资源映射规则"></a>第二种静态资源映射规则</h4><p> 那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； </p><p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 进入方法public String[] getStaticLocations() &#123; return this.staticLocati</span><br><span class="line">ons;&#125;</span><br><span class="line">// 找到对应的值private String[] staticLocations = CLASSPATH_RESOURCE_LOC</span><br><span class="line">ATIONS;</span><br><span class="line">// 找到路径</span><br><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS</span><br><span class="line">= &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;cl</span><br><span class="line">asspath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;</span><br></pre></td></tr></table></figure><p> ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面 数组的内容。 </p><p>所以得出结论，以下四个目录存放的静态资源可以被我们识别： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;&quot;classpath:/resources/&quot;&quot;classpath:/static/&quot;</span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure><p> 我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p><p> 比如我们访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件； </p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="自定义静态资源路径"><a href="#自定义静态资源路径" class="headerlink" title="自定义静态资源路径"></a>自定义静态资源路径</h4><p> 我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在 application.properties中配置； </p><p>spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ </p><p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！ </p><h4 id="首页处理"><a href="#首页处理" class="headerlink" title="首页处理"></a>首页处理</h4><p> 静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public WelcomePageHandlerMapping welcomePageHandlerMapping(Application</span><br><span class="line">Context applicationContext,</span><br><span class="line">FormattingConversionService mvcConversionService,</span><br><span class="line">ResourceUrlProvider mvcResource</span><br><span class="line">UrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new</span><br><span class="line">WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applic</span><br><span class="line">ationContext), applicationContext, getWelcomePage(), </span><br><span class="line">// getWelcomePage 获得欢迎页 </span><br><span class="line">this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); </span><br><span class="line">return welcomePageHandlerMapping;&#125;</span><br><span class="line">点进去继续看</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getRe</span><br><span class="line">sourceLocations(this.resourceProperties.getStaticLocations()); // ::是ja</span><br><span class="line">va8 中新引入的运算符 // Class::function的时候function是属于Class的，应该是静态方</span><br><span class="line">法。 // this::function的funtion是属于这个对象的。 // 简而言之，就是一种语法糖而</span><br><span class="line">已，是一种简写 return Arrays.stream(locations).map(this::getIndexHtml).filt</span><br><span class="line">er(this::isReadable).findFirst();&#125;// 欢迎页就是一个location下的的 index.html 而已</span><br><span class="line">private Resource getIndexHtml(String location) &#123; return this.resourceLoa</span><br><span class="line">der.getResource(location + &quot;index.html&quot;);&#125;</span><br><span class="line">欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</span><br></pre></td></tr></table></figure><p> 比如我访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html 新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 <a href="http://localhost:8080/">http://localhost:8080/</a> 看结果！ </p><p> <strong>关于网站图标说明：</strong>  </p><p><img src="https://s1.ax1x.com/2022/07/06/jULZIs.png" alt="1657029536680"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-09：整合MyBatis</title>
      <link href="/2022/05/28/SpringBoot-09%EF%BC%9A%E6%95%B4%E5%90%88MyBatis/"/>
      <url>/2022/05/28/SpringBoot-09%EF%BC%9A%E6%95%B4%E5%90%88MyBatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-09：整合MyBatis"><a href="#SpringBoot-09：整合MyBatis" class="headerlink" title="SpringBoot-09：整合MyBatis"></a>SpringBoot-09：整合MyBatis</h1><h3 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h3><p>官方文档：<a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a> </p><p>Maven仓库地址：<a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</a>  </p><h4 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h4><p> 1、导入 MyBatis 所需要的依赖 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 2、配置数据库连接信息（不变）  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring: datasource: username: root password: 123456 </span><br><span class="line">#?serverTimezone=UTC解决时区的报错 </span><br><span class="line">url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">#Spring Boot 默认是不注入这些属性值的，需要自己绑定 </span><br><span class="line">#druid 数据源专有配置 </span><br><span class="line">initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetwe</span><br><span class="line">enEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 valida</span><br><span class="line">tionQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false</span><br><span class="line">testOnReturn: false poolPreparedStatements: true</span><br><span class="line">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">#如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/</span><br><span class="line">log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionS</span><br><span class="line">ize: 20 useGlobalDataSourceStat: true connectionProperties: druid.sta</span><br><span class="line">t.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure><p> 3、测试数据库是否连接成功！  </p><p> 4、创建实体类，导入 Lombok！ </p><p> Department.java  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsCon</span><br><span class="line">structor;</span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Department &#123;</span><br><span class="line">private Integer id; </span><br><span class="line">private String departmentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5、创建mapper目录以及对应的 Mapper 接口 </p><p> DepartmentMapper.java  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@Mapper : 表示本类是一个 MyBatis 的 Mapper@Mapper@Repositorypublic interface</span><br><span class="line">DepartmentMapper &#123;</span><br><span class="line">// 获取所有部门信息 List&lt;Department&gt; getDepartments();</span><br><span class="line">// 通过id获得部门 Department getDepartment(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 6、对应的Mapper映射文件  </p><p> DepartmentMapper.xml  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//m</span><br><span class="line">ybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-ma</span><br><span class="line">pper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.DepartmentMapper&quot;&gt;</span><br><span class="line">&lt;select id=&quot;getDepartments&quot; resultType=&quot;Department&quot;&gt; select * fro</span><br><span class="line">m department; &lt;/select&gt;</span><br><span class="line">&lt;select id=&quot;getDepartment&quot; resultType=&quot;Department&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">select * from department where id = #&#123;id&#125;; &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p> 7、maven配置资源过滤问题 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resources&gt; </span><br><span class="line">&lt;resource&gt; </span><br><span class="line">&lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; </span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;/filtering&gt; </span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p> 8、编写部门的 DepartmentController 进行测试！  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerpublic class DepartmentController &#123; @Autowired Dep</span><br><span class="line">artmentMapper departmentMapper; // 查询全部部门 @GetMapping(&quot;/getDe</span><br><span class="line">partments&quot;) public List&lt;Department&gt; getDepartments()&#123; return depa</span><br><span class="line">rtmentMapper.getDepartments(); &#125;</span><br><span class="line">// 查询全部部门 @GetMapping(&quot;/getDepartment/&#123;id&#125;&quot;) public Departmen</span><br><span class="line">t getDepartment(@PathVariable(&quot;id&quot;) Integer id)&#123; return departmentMa</span><br><span class="line">pper.getDepartment(id); &#125; &#125;</span><br></pre></td></tr></table></figure><p> 启动项目访问进行测试！  </p><h4 id="我们增加一个员工类再测试下，为之后做准备"><a href="#我们增加一个员工类再测试下，为之后做准备" class="headerlink" title="我们增加一个员工类再测试下，为之后做准备"></a>我们增加一个员工类再测试下，为之后做准备</h4><p> 1、新建一个pojo类 Employee ；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Employee &#123;</span><br><span class="line">private Integer id; </span><br><span class="line">private String lastName; </span><br><span class="line">private String email;</span><br><span class="line">//1 male, 0 female </span><br><span class="line">private Integer gender; </span><br><span class="line">private Integer department; </span><br><span class="line">private Date birth;</span><br><span class="line">private Department eDepartment; // 冗余设计</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、新建一个 EmployeeMapper 接口 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@Mapper : 表示本类是一个 MyBatis 的 Mapper@Mapper@Repositorypublic interface</span><br><span class="line">EmployeeMapper &#123;</span><br><span class="line">// 获取所有员工信息 List&lt;Employee&gt; getEmployees();</span><br><span class="line">// 新增一个员工 int save(Employee employee);</span><br><span class="line">// 通过id获得员工信息 Employee get(Integer id);</span><br><span class="line">// 通过id删除员工 int delete(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3、编写 EmployeeMapper.xml 配置文件  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//m</span><br><span class="line">ybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-ma</span><br><span class="line">pper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.EmployeeMapper&quot;&gt;</span><br><span class="line">&lt;resultMap id=&quot;EmployeeMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;id&quot; c</span><br><span class="line">olumn=&quot;eid&quot;/&gt; &lt;result property=&quot;lastName&quot; column=&quot;last_name&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt; &lt;result property=&quot;gender&quot;</span><br><span class="line">column=&quot;gender&quot;/&gt; &lt;result property=&quot;birth&quot; column=&quot;birth&quot;/&gt; &lt;</span><br><span class="line">association property=&quot;eDepartment&quot; javaType=&quot;Department&quot;&gt; &lt;id p</span><br><span class="line">roperty=&quot;id&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;departmentName&quot; co</span><br><span class="line">lumn=&quot;dname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getEmployees&quot; resultMap=&quot;EmployeeMap&quot;&gt; select e.id a</span><br><span class="line">s eid,last_name,email,gender,birth,d.id as did,d.department_name as dname</span><br><span class="line">from department d,employee e where d.id = e.department &lt;/se</span><br><span class="line">lect&gt;</span><br><span class="line">&lt;insert id=&quot;save&quot; parameterType=&quot;Employee&quot;&gt; insert into employee</span><br><span class="line">(last_name,email,gender,department,birth) values (#&#123;lastName&#125;,#&#123;ema</span><br><span class="line">il&#125;,#&#123;gender&#125;,#&#123;department&#125;,#&#123;birth&#125;); &lt;/insert&gt;</span><br><span class="line">&lt;select id=&quot;get&quot; resultType=&quot;Employee&quot;&gt; select * from employee w</span><br><span class="line">here id = #&#123;id&#125; &lt;/select&gt;</span><br><span class="line">&lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt; delete from employee wh</span><br><span class="line">ere id = #&#123;id&#125; &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p> 4、编写EmployeeController类进行测试  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line">@Autowired </span><br><span class="line">EmployeeMapper employeeMapper;</span><br><span class="line">// 获取所有员工信息 </span><br><span class="line">@GetMapping(&quot;/getEmployees&quot;) </span><br><span class="line">public List&lt;Employee&gt; getEmployees()&#123; </span><br><span class="line">return employeeMapper.getEmployees(); &#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/save&quot;) </span><br><span class="line">public int save()&#123; </span><br><span class="line">Employee employee = new Employee(); </span><br><span class="line">employee.setLastName(&quot;kuangshen&quot;); employee.setEmail(&quot;qinjiang@qq.com&quot;); employee.setGender(1); </span><br><span class="line">employee.setDepartment(101); </span><br><span class="line">employee.setBirth(new Date()); return employeeMapper.save(employee); &#125;</span><br><span class="line">// 通过id获得员工信息 </span><br><span class="line">@GetMapping(&quot;/get/&#123;id&#125;&quot;) </span><br><span class="line">public Employee get(@PathVariable(&quot;id&quot;) Integer id)&#123; return employeeMapper.get(id); &#125;</span><br><span class="line">// 通过id删除员工 </span><br><span class="line">@GetMapping(&quot;/delete/&#123;id&#125;&quot;) public int delete(@PathVariable(&quot;id&quot;) Integer id)&#123; return employeeMapper.delete(id); &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果完成，搞定收工！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-08：整合Druid</title>
      <link href="/2022/05/27/SpringBoot-08%EF%BC%9A%E6%95%B4%E5%90%88Druid/"/>
      <url>/2022/05/27/SpringBoot-08%EF%BC%9A%E6%95%B4%E5%90%88Druid/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-08：整合Druid"><a href="#SpringBoot-08：整合Druid" class="headerlink" title="SpringBoot-08：整合Druid"></a>SpringBoot-08：整合Druid</h1><h3 id="集成Druid"><a href="#集成Druid" class="headerlink" title="集成Druid"></a>集成Druid</h3><h4 id="Druid简介"><a href="#Druid简介" class="headerlink" title="Druid简介"></a>Druid简介</h4><p> Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 </p><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了 日志监控。</p><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><p> Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 </p><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据 源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 </p><p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a> </p><p>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：  </p><p><img src="https://s1.ax1x.com/2022/07/06/jUL9RP.png" alt="1657026369369"></p><p><img src="https://s1.ax1x.com/2022/07/06/jULCxf.png" alt="1657026378985"></p><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p> 1、添加上 Druid 数据源依赖。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;druid&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源， 但可以 通过 spring.datasource.type 指定数据源。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring: datasource: username: root password: 123456 url: jdbc:mys</span><br><span class="line">ql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;character</span><br><span class="line">Encoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.</span><br><span class="line">alibaba.druid.pool.DruidDataSource # 自定义数据源</span><br></pre></td></tr></table></figure><p> 3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换； </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqxIA.png" alt="1657026491754"></p><p> 4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等 设置项；可以查看源码 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring: datasource: username: root password: 123456 #?serverTimez</span><br><span class="line">one=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTim</span><br><span class="line">ezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com</span><br><span class="line">.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">#Spring Boot 默认是不注入这些属性值的，需要自己绑定 </span><br><span class="line">#druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetwe</span><br><span class="line">enEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 valida</span><br><span class="line">tionQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false</span><br><span class="line">testOnReturn: false poolPreparedStatements: true</span><br><span class="line">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">#如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/</span><br><span class="line">log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionS</span><br><span class="line">ize: 20 useGlobalDataSourceStat: true connectionProperties: druid.sta</span><br><span class="line">t.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure><p> 5、导入Log4j 的依赖  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.config;</span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import org.springframework.bo</span><br><span class="line">ot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.co</span><br><span class="line">ntext.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line">/* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span><br><span class="line">绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就</span><br><span class="line">是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.</span><br><span class="line">pool.DruidDataSource 的同名参数中 */ </span><br><span class="line">@ConfigurationProperties(prefix =&quot;spring.datasource&quot;) </span><br><span class="line">@Bean</span><br><span class="line">public DataSource druidDataSource() &#123;</span><br><span class="line">return new DruidDataSource(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 7、去测试类中测试一下；看是否成功！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line">//DI注入数据源 @Autowired DataSource dataSource;</span><br><span class="line">@Test public void contextLoads() throws SQLException &#123; </span><br><span class="line">//看一下默认数据源 </span><br><span class="line">System.out.println(dataSource.getClass()); </span><br><span class="line">//获得连接</span><br><span class="line">Connection connection = dataSource.getConnection(); System.out.println(connection);</span><br><span class="line">DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.g</span><br><span class="line">etMaxActive()); </span><br><span class="line">System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot;+ druidDataSource.getInitialSize());</span><br><span class="line">//关闭连接 </span><br><span class="line">connection.close(); &#125;&#125;</span><br></pre></td></tr></table></figure><p> 输出结果 ：可见配置参数已经生效！ </p><p><img src="https://s1.ax1x.com/2022/07/06/jULFsS.png" alt="1657026737514"></p><h4 id="配置Druid数据源监控"><a href="#配置Druid数据源监控" class="headerlink" title="配置Druid数据源监控"></a>配置Druid数据源监控</h4><p> Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了 一个默认的 web 页面。 </p><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置 Druid 监控管理后台的Servlet；</span><br><span class="line">//内置 Servlet 容器时没有web.xml文件，所以使用 Sp</span><br><span class="line">ring Boot 的注册 Servlet 方式</span><br><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet </span><br><span class="line">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 </span><br><span class="line">Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); </span><br><span class="line">//后台管理界面的登录账号 </span><br><span class="line">initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); </span><br><span class="line">//后台管理界面的登录密码</span><br><span class="line">//后台允许谁可以访问 </span><br><span class="line">//initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 init</span><br><span class="line">Params.put(&quot;allow&quot;, &quot;&quot;); </span><br><span class="line">//deny：Druid 后台拒绝谁访问 </span><br><span class="line">//initParams.put(&quot;</span><br><span class="line">kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问</span><br><span class="line">//设置初始化参数 bean.setInitParameters(initParams); return bean;&#125;</span><br><span class="line">配置完毕后，我们可以选择访问 ：http://localhost:8080/druid/login.html</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/07/06/jULVaj.png" alt="1657026888000"></p><p> <strong>配置 Druid web 监控 filter 过滤器</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置 Druid 监控 之 web 监控的 filter//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><br><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean webStatFilter() &#123; </span><br><span class="line">FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter());</span><br><span class="line">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 </span><br><span class="line">Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); </span><br><span class="line">initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*,/jdbc/*&quot;); bean.setInitParameters(initParams);</span><br><span class="line">//&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); </span><br><span class="line">return bean;&#125;</span><br><span class="line">平时在工作中，按需求进行配置即可，主要用作监控！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-07：整合JDBC</title>
      <link href="/2022/05/26/SpringBoot-07%EF%BC%9A%E6%95%B4%E5%90%88JDBC/"/>
      <url>/2022/05/26/SpringBoot-07%EF%BC%9A%E6%95%B4%E5%90%88JDBC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-07：整合JDBC"><a href="#SpringBoot-07：整合JDBC" class="headerlink" title="SpringBoot-07：整合JDBC"></a>SpringBoot-07：整合JDBC</h1><h3 id="SpringData简介"><a href="#SpringData简介" class="headerlink" title="SpringData简介"></a>SpringData简介</h3><p> 对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。 </p><p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p><p> Sping Data 官网：<a href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a> </p><p>数据库相关的启动器 ：可以参考官方文档：</p><p> <a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a> </p><h3 id="整合JDBC"><a href="#整合JDBC" class="headerlink" title="整合JDBC"></a>整合JDBC</h3><h4 id="创建测试项目测试数据源"><a href="#创建测试项目测试数据源" class="headerlink" title="创建测试项目测试数据源"></a>创建测试项目测试数据源</h4><p> 1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqjVH.png" alt="1657025109510"></p><p> 2、项目建好之后，发现自动帮我们导入了如下的启动器 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; </span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 3、编写yaml配置文件连接数据库； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring: datasource: username: root password: 123456 #?serverTimez</span><br><span class="line">one=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTim</span><br><span class="line">ezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com</span><br><span class="line">.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p> 4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去 测试类测试一下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTestclass SpringbootDataJdbcApplicationTests &#123;</span><br><span class="line">//DI注入数据源 @Autowired DataSource dataSource;</span><br><span class="line">@Test public void contextLoads() throws SQLException &#123; </span><br><span class="line">//看一下默认数据源 System.out.println(dataSource.getClass()); </span><br><span class="line">//获得连接</span><br><span class="line">Connection connection = dataSource.getConnection(); </span><br><span class="line">System.out.println(connection); </span><br><span class="line">//关闭连接 </span><br><span class="line">connection.close(); &#125;&#125;</span><br></pre></td></tr></table></figure><p> 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没 有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import( &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSo</span><br><span class="line">urceJmxConfiguration.class&#125;)</span><br><span class="line">protected static class PooledDataSourceConfiguration &#123; protected PooledDataSourceConfiguration() &#123; &#125;&#125;</span><br><span class="line">@Import( &#123;Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSo</span><br><span class="line">urceJmxConfiguration.class&#125;)</span><br><span class="line">protected static class PooledDataSourceConfigur</span><br><span class="line">ation &#123; protected PooledDataSourceConfiguration() &#123; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用 HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； </p><p> <strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、 Tomcat jdbc 等连接池更加优秀；</strong> </p><p> 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限 定名。 </p><p> 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一 个对象 JdbcTemplate </p><h4 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h4><p> 1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了 连接，就可以使用原生的 JDBC 语句来操作数据库； </p><p> 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封 装，即JdbcTemplate。 </p><p> 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p><p> 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只 需自己注入即可使用</p><p> 5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 </p><p> <strong>JdbcTemplate</strong>主要提供以下几类方法： </p><ul><li> execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li> update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于 执行批处理相关语句；</li><li> query方法及queryForXXX方法：用于执行查询相关语句；</li><li> call方法：用于执行存储过程、函数相关语句。  </li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p> 编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import java.util.Date;import java.util.List;import java.util.Map;</span><br><span class="line">@RestController@RequestMapping(&quot;/jdbc&quot;)</span><br><span class="line">public class JdbcController &#123;</span><br><span class="line">/** * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.c</span><br><span class="line">ore.JdbcTemplate * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作 * 还</span><br><span class="line">能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接 */ </span><br><span class="line">@Autowired JdbcTemplate jdbcTemplate;</span><br><span class="line">//查询employee表中所有数据 </span><br><span class="line">//List 中的1个 Map 对应数据库的 1行数据 </span><br><span class="line">//Map中的 key 对应数据库的字段名，value 对应数据库的字段值 </span><br><span class="line">@GetMapping(&quot;/list&quot;) </span><br><span class="line">public List&lt;Map&lt;String, Object&gt;&gt; userList()&#123; String sql = &quot;select * fr</span><br><span class="line">om employee&quot;; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryFor</span><br><span class="line">List(sql); return maps; &#125; </span><br><span class="line">//新增一个用户 </span><br><span class="line">@GetMapping(&quot;/add&quot;) </span><br><span class="line">public String addUser()&#123; </span><br><span class="line">//插入语句，注意时间问题 </span><br><span class="line">String sql = &quot;insert into employee(last_name, email,gender,department,birth)&quot; +</span><br><span class="line">&quot; values (&#x27;狂神说&#x27;,&#x27;24736743@qq.com&#x27;,1,101,&#x27;&quot;+ new Date().toLoca</span><br><span class="line">leString() +&quot;&#x27;)&quot;; jdbcTemplate.update(sql); //查询 retu</span><br><span class="line">rn &quot;addOk&quot;; &#125;</span><br><span class="line">//修改用户信息 </span><br><span class="line">@GetMapping(&quot;/update/&#123;id&#125;&quot;) </span><br><span class="line">public String updateUser(</span><br><span class="line">@PathVariable(&quot;id&quot;) int id)&#123; </span><br><span class="line">//插入语句 </span><br><span class="line">String sql = &quot;update employee set last_name=?,email=? where id=&quot;+id; //数据 </span><br><span class="line">Object[] objects = new Object[2]; objects[0] = &quot;秦疆&quot;; objects[1] = &quot;24</span><br><span class="line">736743@sina.com&quot;; jdbcTemplate.update(sql,objects); </span><br><span class="line">//查询</span><br><span class="line">return &quot;updateOk&quot;; &#125;</span><br><span class="line">//删除用户 </span><br><span class="line">@GetMapping(&quot;/delete/&#123;id&#125;&quot;) </span><br><span class="line">public String delUser(@PathVariable(&quot;id&quot;) int id)&#123; //插入语句 String sql = &quot;delete from employee where id=?&quot;; jdbcTemplate.update(sql,id); //查询</span><br><span class="line">return &quot;deleteOk&quot;; &#125; &#125;</span><br></pre></td></tr></table></figure><p> 测试请求，结果正常； </p><p>到此，CURD的基本操作，使用 JDBC 就搞定了。  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-06：自定义starter</title>
      <link href="/2022/05/25/SpringBoot-06%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
      <url>/2022/05/25/SpringBoot-06%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-06：自定义starter"><a href="#SpringBoot-06：自定义starter" class="headerlink" title="SpringBoot-06：自定义starter"></a>SpringBoot-06：自定义starter</h1><h3 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h3><p> 我们分析完毕了源码以及自动装配的过程，我们可以尝试自定义一个启动器来玩玩！ </p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p> 启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库；</p><p> 命名归约：</p><p> 官方命名：  </p><ul><li><p> 前缀：spring-boot-starter-xxx</p></li><li><p>比如：spring-boot-starter-web….</p><p> 自定义命名：</p></li><li><p> xxx-spring-boot-starter </p></li><li><p>比如：mybatis-spring-boot-starter </p></li></ul><h4 id="编写启动器"><a href="#编写启动器" class="headerlink" title="编写启动器"></a>编写启动器</h4><p> 1、在IDEA中新建一个空项目 spring-boot-starter-diy </p><p> 2、新建一个普通Maven模块：kuang-spring-boot-starter </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqoP1.png" alt="1657022845507"></p><p> 3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure  </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqHxK.png" alt="1657022865889"></p><p> 4、点击apply即可，基本结构 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqLrD.png" alt="1657022881798"></p><p> 5、在我们的 starter 中 导入 autoconfigure 的依赖！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 启动器 --&gt;</span><br><span class="line">&lt;dependencies&gt; &lt;!-- 引入自动配置模块 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.kuang&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p> 6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！  </p><p><img src="https://s1.ax1x.com/2022/07/06/jULSPI.png" alt="1657022918411"></p><p> 7、我们编写一个自己的服务 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line">public class HelloService &#123;</span><br><span class="line">HelloProperties helloProperties;</span><br><span class="line">public HelloProperties getHelloProperties() &#123; return helloProper</span><br><span class="line">ties; &#125;</span><br><span class="line">public void setHelloProperties(HelloProperties helloProperties) &#123;</span><br><span class="line">this.helloProperties = helloProperties; &#125;</span><br><span class="line">public String sayHello(String name)&#123; return helloProperties.getP</span><br><span class="line">refix() + name + helloProperties.getSuffix(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 8、编写HelloProperties 配置类 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">// 前缀 kuang.hello@ConfigurationProperties(prefix = &quot;kuang.hello&quot;)</span><br><span class="line">public class HelloProperties &#123;</span><br><span class="line">private String prefix; private String suffix;</span><br><span class="line">public String getPrefix() &#123; return prefix; &#125;</span><br><span class="line">public void setPrefix(String prefix) &#123; this.prefix = prefix;&#125;</span><br><span class="line">public String getSuffix() &#123; return suffix; &#125;</span><br><span class="line">public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 9、编写我们的自动配置类并注入bean，测试 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import rg.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">@Configuration@ConditionalOnWebApplication //web应用生效@EnableConfiguration Poperties(HelloProperties.class)public class HelloServiceAutoConfiguration</span><br><span class="line">&#123;</span><br><span class="line">@Autowired HelloProperties helloProperties;</span><br><span class="line">@Bean </span><br><span class="line">public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties);</span><br><span class="line">return service; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 10、在resources编写一个自己的 META-INF\spring.factories  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfigurat</span><br><span class="line">ion=\com.kuang.HelloServiceAutoConfiguration</span><br></pre></td></tr></table></figure><p> 11、编写完成后，可以安装到maven仓库中！  </p><p><img src="https://s1.ax1x.com/2022/07/06/jULiM8.png" alt="1657023051278"></p><h4 id="新建项目测试我们自己写的启动器"><a href="#新建项目测试我们自己写的启动器" class="headerlink" title="新建项目测试我们自己写的启动器"></a>新建项目测试我们自己写的启动器</h4><p>1、新建一个SpringBoot 项目 </p><p>2、导入我们自己写的启动器 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;com.kuang&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt; </span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3、编写一个 HelloController 进行测试我们自己的写的接口！  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">@RestControllerpublic class HelloController &#123;</span><br><span class="line">@Autowired HelloService helloService;</span><br><span class="line">@RequestMapping(&quot;/hello&quot;) public String hello()&#123; return hello</span><br><span class="line">Service.sayHello(&quot;zxc&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 4、编写配置文件 application.properties </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuang.hello.prefix=&quot;ppp&quot;kuang.hello.suffix=&quot;sss&quot;</span><br></pre></td></tr></table></figure><p> 5、启动项目进行测试，结果成功 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqvad.png" alt="1657023216726"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-05：自动配置原理</title>
      <link href="/2022/05/24/SpringBoot-05%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2022/05/24/SpringBoot-05%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-05：自动配置原理"><a href="#SpringBoot-05：自动配置原理" class="headerlink" title="SpringBoot-05：自动配置原理"></a>SpringBoot-05：自动配置原理</h1><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p> 配置文件到底能写什么？怎么写？ </p><p>SpringBoot官方文档中有大量的配置，我们无法全部记住 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqT8x.png" alt="1657021659952"></p><h4 id="分析自动配置原理"><a href="#分析自动配置原理" class="headerlink" title="分析自动配置原理"></a>分析自动配置原理</h4><p> 我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><br><span class="line">@Configuration</span><br><span class="line">//启动指定类的ConfigurationProperties功能； </span><br><span class="line">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； </span><br><span class="line">//并把HttpProperties加入到ioc容器中</span><br><span class="line">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span><br><span class="line">//Spring底层@Conditional注解 </span><br><span class="line">//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； </span><br><span class="line">//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span><br><span class="line">@ConditionalOnWebApplication( type = Type.SERVLET)</span><br><span class="line">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.cslass&#125;)</span><br><span class="line">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； </span><br><span class="line">//如果不存在，判断也是成立的 </span><br><span class="line">//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效</span><br><span class="line">的；</span><br><span class="line">@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = &#123;&quot;enabled&quot;&#125;, matchIfMissing = true)</span><br><span class="line">public class HttpEncodingAutoConfiguration &#123; </span><br><span class="line">//他已经和SpringBoot的配置文件映射了 private final Encoding properties; </span><br><span class="line">//只有一个有参构造器的情况下，参数的值就会从容器中拿 </span><br><span class="line">public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; </span><br><span class="line">//给容器中添加一个组件，这个组件的某些值需要从properties中获取 </span><br><span class="line">@Bean </span><br><span class="line">@ConditionalOnMissingBean //判断容器没有这个组件？ </span><br><span class="line">public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.should Force(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; //。。。。。。。&#125;</span><br></pre></td></tr></table></figure><p> <strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong> </p><ul><li> 一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li><li> 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； </li><li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； </li><li>配置文件能配置什么就可以参照某个功能对应的这个属性类 </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties &#123; // .....&#125;</span><br></pre></td></tr></table></figure><p> 我们去配置文件里面试试前缀，看提示！ </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqqKO.png" alt="1657022185430"></p><p> 这就是自动装配的原理！ </p><h4 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h4><p>1、SpringBoot启动会加载大量的自动配置类 </p><p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； </p><p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要 再手动配置了） </p><p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定 这些属性的值即可； </p><p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件 </p><p>xxxxProperties:封装配置文件中相关属性； </p><h4 id="了解：-Conditional"><a href="#了解：-Conditional" class="headerlink" title="了解：@Conditional"></a>了解：@Conditional</h4><p> 了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； </p><p>@Conditional派生注解（Spring注解版原生的@Conditional作用） </p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； </p><p><img src="https://s1.ax1x.com/2022/07/06/jUq726.png" alt="1657022331463"></p><p> 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置 类，但不是所有的都生效了。</p><p> 我们怎么知道哪些自动配置类生效？ </p><p> 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的 知道哪些自动配置类生效； </p><p> #开启springboot的调试类debug=true </p><p> Positive matches:（自动配置类启用的：正匹配） </p><p> Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） </p><p> Unconditional classes: （没有条件的类） </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-04：JSR303数据校验及多环境切换</title>
      <link href="/2022/05/23/SpringBoot-04%EF%BC%9AJSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
      <url>/2022/05/23/SpringBoot-04%EF%BC%9AJSR303%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-04：JSR303数据校验及多环境切换"><a href="#SpringBoot-04：JSR303数据校验及多环境切换" class="headerlink" title="SpringBoot-04：JSR303数据校验及多环境切换"></a>SpringBoot-04：JSR303数据校验及多环境切换</h1><h2 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h2><h4 id="先看看如何使用"><a href="#先看看如何使用" class="headerlink" title="先看看如何使用"></a>先看看如何使用</h4><p> Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我 们这里来写个注解让我们的name只能支持Email格式； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">@Validated</span><br><span class="line">//数据校验</span><br><span class="line">public class Person &#123;</span><br><span class="line">@Email(message=&quot;邮箱格式错误&quot;) //name</span><br><span class="line">必须是邮箱格式 private String name;&#125;</span><br><span class="line">运行结果 ：default message [不是一个合法的电子邮件地址];</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/07/06/jUq4a9.png" alt="1656947733450"></p><p> 使用数据校验，可以保证数据的正确性； </p><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NotNull(message=&quot;名字不能为空&quot;)</span><br><span class="line">private String userName;</span><br><span class="line">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span><br><span class="line">private int age;</span><br><span class="line">@Email(message=&quot;邮箱格式错误&quot;)</span><br><span class="line">private String email;</span><br><span class="line">空检查</span><br><span class="line">@Null 验证对象是否为null@NotNull 验证对象是否不为null, 无法查检长度为0的字符串</span><br><span class="line">@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去</span><br><span class="line">掉前后空格.</span><br><span class="line">@NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查@AssertTrue验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false长度检查</span><br><span class="line">@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给</span><br><span class="line">定的范围之内 </span><br><span class="line">@Length(min=, max=) string is between min and max included.日期检查</span><br><span class="line">@Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证</span><br><span class="line">Date 和 Calendar 对象是否在当前时间之后 </span><br><span class="line">@Pattern 验证 String 对象是否符合正则表达式的规则</span><br><span class="line">.......等等除此以外，我们还可以自定义一些数据校验规则</span><br></pre></td></tr></table></figure><h2 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h2><p> profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；  </p><h4 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h4><p> 我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； </p><p>例如：</p><p> application-test.properties 代表测试环境配置 </p><p>application-dev.properties 代表开发环境配置 </p><p>但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境：</p><p> #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoo t，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev </p><h4 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h4><p> 和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server: port: 8081#选择要激活那个环境块spring: profiles: active: prod</span><br><span class="line">---server: port: 8083spring: profiles: dev #配置环境的名称</span><br><span class="line">---</span><br><span class="line">server: port: 8084spring: profiles: prod #配置环境的名称</span><br></pre></td></tr></table></figure><p> 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用 properties配置文件的！ </p><h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p> 外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！  </p><p> 官方外部配置文件说明参考文档  </p><p><img src="https://s1.ax1x.com/2022/07/06/jUq55R.png" alt="1656948273509"></p><p> springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置 文件： </p><p>优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的co nfig文件夹配置文件优先级4：资源路径下配置文件 </p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置； </p><p>SpringBoot会从这四个位置全部加载主配置文件；互补配置； </p><p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； </p><p>#配置项目的访问路径server.servlet.context-path=/kuang </p><h4 id="拓展，运维小技巧"><a href="#拓展，运维小技巧" class="headerlink" title="拓展，运维小技巧"></a>拓展，运维小技巧</h4><p> 指定位置加载配置文件 </p><p>我们还可以通过spring.config.location来改变默认的配置文件位置 </p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况， 一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 </p><p>java -jar spring-boot-config.jar –spring.config.location=F:/application.pr operties </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-03：yaml配置注入</title>
      <link href="/2022/05/22/SpringBoot-03%EF%BC%9Ayaml%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/05/22/SpringBoot-03%EF%BC%9Ayaml%E9%85%8D%E7%BD%AE%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-03：yaml配置注入"><a href="#SpringBoot-03：yaml配置注入" class="headerlink" title="SpringBoot-03：yaml配置注入"></a>SpringBoot-03：yaml配置注入</h1><h2 id="yaml语法学习"><a href="#yaml语法学习" class="headerlink" title="yaml语法学习"></a>yaml语法学习</h2><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p> SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 </p><ul><li> application.properties        语法结构 ：key=value </li><li> application.yml       语法结构 ：key：空格 value </li></ul><p> <strong>配置文件的作用</strong> ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；  </p><h4 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h4><p> YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时， YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） </p><p> <strong>这种语言以数据作为中心，而不是以标记语言为重点！</strong> </p><p> 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： </p><h4 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h4><p>说明：语法要求严格！ </p><ol><li><p>空格不能省略</p></li><li><p>以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 </p></li><li><p>属性和值的大小写都是十分敏感的。 </p><p><strong>字面量：普通的值 [ 数字，布尔值，字符串 ]</strong> </p><p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； </p></li></ol><p>K  :  V</p><p> <strong>注意：</strong></p><ul><li> “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \n shen” 输出 ：kuang 换行 shen </li><li>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \n shen’ 输出 ：kuang \n shen </li></ul><p> <strong>对象、Map（键值对）</strong> </p><p> #对象、Map格式k: v1: v2: </p><p>在下一行来写对象的属性和值得关系，注意缩进；比如： </p><p> student: name: qinjiang age: 3 </p><p> 行内写法 </p><p>student: {name: qinjiang,age: 3}  </p><p> <strong>数组（ List、set ）</strong>  </p><p> 用 - 值表示数组中的一个元素,比如： </p><p>pets: - cat - dog - pig  </p><p> 行内写法 </p><p>pets: [cat,dog,pig]  </p><p> <strong>修改SpringBoot的默认端口号</strong> </p><p>port:8080（默认）</p><h2 id="注入配置文件"><a href="#注入配置文件" class="headerlink" title="注入配置文件"></a>注入配置文件</h2><p> yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ </p><h4 id="yaml注入配置文件"><a href="#yaml注入配置文件" class="headerlink" title="yaml注入配置文件"></a>yaml注入配置文件</h4><ol><li><p> 1、在springboot项目中的resources目录下新建一个文件 application.yml </p></li><li><p>2、编写一个实体类 Dog；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.springboot.pojo;</span><br><span class="line">@Component //注册bean到容器中</span><br><span class="line">public class Dog &#123; </span><br><span class="line">private String name; </span><br><span class="line">private Integer age; </span><br><span class="line">//有参无参构造、get、set方法、toString()方法 &#125;</span><br></pre></td></tr></table></figure></li><li><p> 思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下 ；</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">public class Dog &#123; </span><br><span class="line">@Value(&quot;阿黄&quot;) private String name; </span><br><span class="line">@Value(&quot;18&quot;) private Integer age;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 在SpringBoot的测试类下注入狗狗输出一下； </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTestclass DemoApplicationTests &#123;</span><br><span class="line">@Autowired //将狗狗自动注入进来 Dog dog;</span><br><span class="line">@Test </span><br><span class="line">public void contextLoads() &#123; </span><br><span class="line">System.out.println(dog); //打印看下狗狗对象 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果成功输出，@Value注入成功，这是我们原来的办法对吧。 </code></pre><p>   <img src="https://s1.ax1x.com/2022/07/06/jUqBUs.png" alt="1656945708014"></p><ol start="5"><li> 我们在编写一个复杂一点的实体类：Person 类  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean到容器中</span><br><span class="line">public class Person &#123; </span><br><span class="line">private String name;</span><br><span class="line">private Integer age; </span><br><span class="line">private Boolean happy; </span><br><span class="line">private Date birth; </span><br><span class="line">private Map&lt;String,Object&gt; maps; </span><br><span class="line">private List&lt;Object&gt; lists; private Dog dog; </span><br><span class="line">//有参无参构造、get、set方法、toString()方法 &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: &#123;k1</span><br><span class="line">: v1,k2: v2&#125; lists: - code - girl - music dog: name: 旺财 age:</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol start="7"><li> 我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告</span><br><span class="line">诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix = “person” :</span><br><span class="line">将配置文件中的person下面的所有属性一一对应*/</span><br><span class="line">@Component //注册bean</span><br><span class="line">@Configuration Properties(prefix = &quot;person&quot;)</span><br><span class="line">public class Person &#123; private String name; </span><br><span class="line">private Integer age; </span><br><span class="line">private Boolean happy; </span><br><span class="line">private Date birth; </span><br><span class="line">private Map&lt;String,Object&gt; maps; </span><br><span class="line">private List&lt;Object&gt; lists; </span><br><span class="line">private Dog dog;&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li> IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ </li></ol><p>   <img src="https://s1.ax1x.com/2022/07/06/jUqcvT.png" alt="1656945995133"></p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;</span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-boot-configurationprocessor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li> 确认以上配置都OK之后，我们去测试类中测试一下：  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTestclass DemoApplicationTests &#123;</span><br><span class="line">@Autowired Person person; //将person自动注入进来</span><br><span class="line">@Test </span><br><span class="line">public void contextLoads() &#123; System.out.println(person)</span><br><span class="line">; //打印person信息 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <img src="https://s1.ax1x.com/2022/07/06/jUqRrF.png" alt="1656946321678"></p><p> <strong>yaml配置注入到实体类完全OK！</strong> </p><p> 课堂测试： </p><p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败 </p><p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2； </p><h4 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h4><p><strong>@PropertySource</strong> ：加载指定的配置文件； </p><p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；  </p><ol><li><p>我们去在resources目录下新建一个person.properties文件 </p><p> name=kuangshen </p></li><li><p> 然后在我们的代码中指定加载person.properties文件 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><br><span class="line">@Component //注册bean</span><br><span class="line">public class Person &#123;</span><br><span class="line">@Value(&quot;$&#123;name&#125;&quot;) private String name;</span><br><span class="line">...... &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 再次输出测试一下：指定配置文件绑定成功！ </li></ol><p>   <img src="https://s1.ax1x.com/2022/07/06/jUq2KU.png" alt="1656946799061"></p><h4 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h4><p> 配置文件还可以编写占位符生成随机数 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person: name: qinjiang$&#123;random.uuid&#125; # 随机uuid age: $&#123;random.int&#125; #</span><br><span class="line">随机int happy: false birth: 2000/01/01 maps: &#123;k1: v1,k2: v2&#125; lis</span><br><span class="line">ts: - code - girl - music dog: name: $&#123;person.hello:</span><br><span class="line">other&#125;_旺财 age: 1</span><br></pre></td></tr></table></figure><h4 id="回顾properties配置"><a href="#回顾properties配置" class="headerlink" title="回顾properties配置"></a>回顾properties配置</h4><p> 我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其 他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们 没有讲，我们来唠唠！ </p><p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings–&gt;FileEncodings 中配置；  </p><p> 测试步骤：  </p><ol><li> 新建一个实体类User </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">public class User &#123; </span><br><span class="line">private String name; </span><br><span class="line">private int age; </span><br><span class="line">private String sex;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 编辑配置文件 user.properties </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user1.name=kuangshenuser1.age=18user1.sex=男</span><br></pre></td></tr></table></figure><ol start="3"><li> 我们在User类上使用@Value来进行注入！  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //注册bean</span><br><span class="line">@PropertySource(value = &quot;classpath:user.properties&quot;)</span><br><span class="line">public class User &#123; </span><br><span class="line">//直接使用@value </span><br><span class="line">@Value(&quot;$&#123;user.name&#125;&quot;) //从配置文件中取值</span><br><span class="line">private String name; </span><br><span class="line">@Value(&quot;#&#123;9*2&#125;&quot;) // #&#123;SPEL&#125; Spring表达式 </span><br><span class="line">private int age; </span><br><span class="line">@Value(&quot;男&quot;) // 字面量 </span><br><span class="line">private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> Springboot测试  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTestclass DemoApplicationTests &#123;</span><br><span class="line">@Autowired User user;</span><br><span class="line">@Test public void contextLoads() &#123; System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>结果正常输出： </code></pre><p>   <img src="https://s1.ax1x.com/2022/07/06/jUqWb4.png" alt="1656947002613"></p><h4 id="对比小结"><a href="#对比小结" class="headerlink" title="对比小结"></a>对比小结</h4><p> @Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqhVJ.png" alt="1656947024648"></p><p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 </p><p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字 母默认是大写的。这就是松散绑定。可以测试一下 </p><p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 </p><p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 </p><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p> 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； </p><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； </p><p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不 要犹豫！  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-02：运行原理初探</title>
      <link href="/2022/05/21/SpringBoot-02%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/05/21/SpringBoot-02%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-02：运行原理初探"><a href="#SpringBoot-02：运行原理初探" class="headerlink" title="SpringBoot-02：运行原理初探"></a>SpringBoot-02：运行原理初探</h1><h2 id="运行原理探究"><a href="#运行原理探究" class="headerlink" title="运行原理探究"></a>运行原理探究</h2><p> 我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起； </p><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><h4 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h4><p> 其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; </span><br><span class="line">&lt;relativePath/&gt; </span><br><span class="line">&lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p> 点进去，发现还有一个父依赖 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; </span><br><span class="line">&lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p> 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p> <strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配 置版本了</strong> </p><h4 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器 </p><p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件； </p><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些 starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未 来也可以自己自定义 starter； </p><h3 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h3><h4 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@SpringBootApplication 来标注一个主程序类//说明这是一个Spring Boot应用@SpringBoo</span><br><span class="line">tApplicationpublic class SpringbootApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">//以为是启动了一个方法，没想到启动了一个服务 </span><br><span class="line">SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但是一个简单的启动类并不简单！我们来分析一下这些注解都干了什么 </p><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p> 作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来 启动SpringBoot应用； </p><p>进入这个注解：可以看到上面还有很多其他注解！  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)</span><br><span class="line">public @interface SpringBootApplication </span><br><span class="line">&#123;// ......&#125;</span><br></pre></td></tr></table></figure><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p> 这个注解在Spring中很重要 ,它对应XML配置中的元素。 </p><p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 </p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p> 作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； </p><p>我们继续进去这个注解查看  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 点进去得到下面的 </span><br><span class="line">@Component</span><br><span class="line">@Configurationpublic </span><br><span class="line">@interface </span><br><span class="line">SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； </p><p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ </p><p>我们回到 SpringBootApplication 注解中继续看。 </p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p> <strong>@EnableAutoConfiguration</strong> ：开启自动配置功能 </p><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉 SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： </p><p><strong>@AutoConfigurationPackage</strong> ：自动配置包 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;&#125;</span><br></pre></td></tr></table></figure><p> <strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件 </p><p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 </p><p> <strong>@Import({AutoConfigurationImportSelector.class}) ：</strong>给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去 这个类看源码： </p><ol><li><p>1、这个类中有一个这样的方法 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获得候选的配置</span><br><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; </span><br><span class="line">//这里的</span><br><span class="line">getSpringFactoriesLoaderFactoryClass（）方法 </span><br><span class="line">//返回的就是我们最开始看的启动自动导入配置文件的注解类；</span><br><span class="line">EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); </span><br><span class="line">return configurations;&#125;</span><br></pre></td></tr></table></figure></li><li><p> 这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类 loadFactoryNames() 方法 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable</span><br><span class="line">ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getNa</span><br><span class="line">me(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFa</span><br><span class="line">ctories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()</span><br><span class="line">);&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p> 我们继续点击查看 loadSpringFactories 方法  </p></li><li><p> 发现一个多次出现的文件：spring.factories，全局搜索它 </p></li></ol><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h4><p> 我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！  </p><p><img src="https://s1.ax1x.com/2022/07/06/jUq62V.png" alt="1656861976484"></p><p> <strong>WebMvcAutoConfiguration</strong>  </p><p> 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqy80.png" alt="1656862000276"></p><p> 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着 熟悉一下！ </p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的 JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 </p><p> <strong>结论：</strong> </p><ol><li> SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的 值  </li><li> 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； </li><li> 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；  </li><li> 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所 有组件 ， 并配置好这些组件  </li><li> 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；  </li></ol><p> <strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong>  </p><h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><h4 id="不简单的方法"><a href="#不简单的方法" class="headerlink" title="不简单的方法"></a>不简单的方法</h4><p> 我最初以为就是运行了一个main方法，没想到却开启了一个服务；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplicationpublic class SpringbootApplication &#123; </span><br><span class="line">public static void main(String[] args) &#123; SpringApplication.run(SpringbootApplication.class, args); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>SpringApplication.run分析</strong> </p><p> 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；  </p><h4 id="SpringApplication-1"><a href="#SpringApplication-1" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><p> 这个类主要做了以下四件事情： </p><ol><li> 推断应用的类型是普通的项目还是Web项目 </li><li> 查找并加载所有可用初始化器 ， 设置到initializers属性中 </li><li> 找出所有的应用程序监听器，设置到listeners属性中 </li><li> 推断并设置main方法的定义类，找到运行的主类 </li></ol><h4 id="run方法流程分析"><a href="#run方法流程分析" class="headerlink" title="run方法流程分析"></a>run方法流程分析</h4><p><img src="https://s1.ax1x.com/2022/07/06/jUqsCq.png" alt="1656862616001"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-01：Hello,World！</title>
      <link href="/2022/05/20/SpringBoot-01%EF%BC%9AHello,World%EF%BC%81/"/>
      <url>/2022/05/20/SpringBoot-01%EF%BC%9AHello,World%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-01：Hello-World！"><a href="#SpringBoot-01：Hello-World！" class="headerlink" title="SpringBoot-01：Hello,World！"></a>SpringBoot-01：Hello,World！</h1><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><h3 id="回顾什么是Spring"><a href="#回顾什么是Spring" class="headerlink" title="回顾什么是Spring"></a>回顾什么是Spring</h3><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 <strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong>  </p><h3 id="Spring是如何简化Java开发的"><a href="#Spring是如何简化Java开发的" class="headerlink" title="Spring是如何简化Java开发的"></a>Spring是如何简化Java开发的</h3><p> 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： </p><ol><li>基于POJO的轻量级和最小侵入性编程，所有东西都是bean； </li><li>通过IOC，依赖注入（DI）和面向接口实现松耦合； </li><li>基于切面（AOP）和惯例进行声明式编程； </li><li>通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； </li></ol><h3 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h3><p>​         学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的 SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的 技术也在不断的变化、改造吗？建议都可以去经历一遍；  </p><pre><code>     言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb 框架的好处，官方说是**简化开发，约定大于配置**， you can &quot;just run&quot;，能迅速的开发web应用，几行代码开 发一个http接口。       所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只 需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根 据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率， 嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 </code></pre><p>​        是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。  </p><pre><code>     随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来 的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；      Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是 用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方 案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核 心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大 量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），**Spring Boot 应用中这 些第三方库几乎可以零配置的开箱即用**。       简单来说就是SpringBoot其实不是什么新的框架，它**默认配置了很多框架**的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</code></pre><p>​        Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善， Spring Boot 已经当之无愧成为 Java 领域最热门的技术。  </p><p> <strong>Spring Boot的主要优点：</strong>  </p><ul><li> 为所有Spring开发者更快的入门 </li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置 </li><li>内嵌式容器简化Web项目 </li><li>没有冗余代码生成和XML配置的要求 </li></ul><h2 id="Hello，World"><a href="#Hello，World" class="headerlink" title="Hello，World"></a>Hello，World</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p> 我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对 Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。  </p><p> 我的环境准备： </p><ul><li> java version “1.8.0_181” </li><li>Maven-3.6.1 </li><li>SpringBoot 2.x 最新版 </li></ul><p> 开发工具：  IDEA </p><h3 id="创建基础项目说明"><a href="#创建基础项目说明" class="headerlink" title="创建基础项目说明"></a>创建基础项目说明</h3><p>Spring官方提供了非常方便的工具让我们快速构建应用 </p><p>Spring Initializr：<a href="https://start.spring.io/">https://start.spring.io/</a> </p><p>项目创建方式一：使用Spring Initializr 的 Web页面创建项目 </p><ol><li>打开 <a href="https://start.spring.io/">https://start.spring.io/</a> </li><li>填写项目信息 </li><li>点击”Generate Project“按钮生成项目；下载此项目 </li><li>解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 </li><li>如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。  </li></ol><p> 项目创建方式二：<strong>使用 IDEA 直接创建项目！！！</strong> </p><ol><li>创建一个新项目 </li><li>选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 </li><li>填写项目信息 </li><li>选择初始化的组件（初学勾选 Web 即可） </li><li>填写项目路径 </li><li>等待项目构建成功 </li></ol><p> 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 </p><ol><li>程序的主启动类 </li><li>一个 application.properties 配置文件 </li><li>一个 测试类 </li><li>一个 pom.xml </li></ol><h3 id="pom-xml-分析"><a href="#pom-xml-分析" class="headerlink" title="pom.xml 分析"></a>pom.xml 分析</h3><p> 打开pom.xml，看看Spring Boot项目的依赖： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-pom.xml- 【看创建出的那个xml文件】 主要的模块为 springbootStarter！！！ 依赖模块 插件模块</span><br></pre></td></tr></table></figure><h3 id="编写一个http接口"><a href="#编写一个http接口" class="headerlink" title="编写一个http接口"></a>编写一个http接口</h3><ol><li><p>在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 </p></li><li><p>在包中新建一个HelloController类 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerpublic class HelloController &#123;</span><br><span class="line">@RequestMapping(&quot;/hello&quot;) </span><br><span class="line">public String hello() </span><br><span class="line">&#123; return &quot;Hello World&quot;; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> 编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！ </p></li></ol><p>   直接访问IP地址，即可查看出这个内容</p><ol start="4"><li> 简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务 项目！ </li></ol><h3 id="将项目打成jar包，点击-maven的-package"><a href="#将项目打成jar包，点击-maven的-package" class="headerlink" title="将项目打成jar包，点击 maven的 package"></a>将项目打成jar包，点击 maven的 package</h3><p>点击右上角的maven中选中package即可实现对项目的打包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用</span><br><span class="line">例会影响数据库数据 跳过测试用例执 --&gt;</span><br><span class="line">&lt;plugin&gt; </span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins</span><br><span class="line">&lt;/groupId&gt; </span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; </span><br><span class="line">&lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; </span><br><span class="line">&lt;skipTests&gt;true&lt;/skipTests&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p> 如果打包成功，则会在target目录下生成一个 jar 包 </p><p><img src="https://s1.ax1x.com/2022/07/06/jUqD5n.png" alt="1656858222780"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务</title>
      <link href="/2022/05/11/Spring/Spring%E4%BA%8B%E5%8A%A1%EF%BC%9A/"/>
      <url>/2022/05/11/Spring/Spring%E4%BA%8B%E5%8A%A1%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Spring****事务：</strong></p><p>什么是事务：</p><p>事务逻辑上的一组对数据对操作，组成这些操作的各个逻辑单元，要么一起成功，要么一起失败。</p><p><strong>事务特性（<strong><strong>4</strong></strong>种）：</strong></p><p>原子性（atomicity）：强调事务的不可分割；<br> 一致性（consistency）：事务的执行前后数据的完整性保持一致；<br> 隔离性（isolation）：一个事务的执行的过程中，不应该受到其他事务的干扰；<br> 持久性（durability）：事务一旦结束，数据就持久到数据库。</p><p><strong>如果不考虑隔离性引发的安全性问题：</strong></p><p>脏读：一个事务读到了另一个事务未提交的数据</p><p>不可重复读：一个事务督导另一个事务已经提交的update的数据导致多次查询结果不一致</p><p>虚幻读：一个事务读到了另一个事务已经提交的insert的数据导致多次查询结果不一致。</p><p><strong>解决读问题：设置事务隔离级别：  5种</strong></p><p>DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别；<br> 未提交读（read uncommited）：脏读，不可重复读，虚读都有可能发生<br> 已提交读（read commited）：避免脏读。但是不可重复读和虚读都有可能发生；<br> 可重复读（repeatable read）：避免脏读和不可重复读，但是虚读有可能发生；<br> 串行化的（serializable）：避免以上所有读问题。<br> MySQL默认：可重复读<br> Oracle默认：已提交读</p><p><img src="file:///C:/Users/123/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p>read uncommitted：是最低读事务隔离级别，它允许另外一个事务可以看到这个事务未提交读数据。<br> read commited： 保证一个事务提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<br> repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻想读。它除了保证一个事务不能被另外一个事务读取未提交读数据之外还避免了一下情况产生（不可重复读）。<br> serializable：这是花费最高代价但最可靠但事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读（避免三种）。</p><p><strong>事务读传播行为</strong></p><p><strong>PROPAGION_XXX****：事务的传播行为</strong><br> * 保证同一个事务中<br> PROPAGATION_REQUIRED   如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。<br> PROPAGATION_SUPPORTS    如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。<br> PROPAGATION_MANDATORY    如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。<br> * 保证没有在同一个事务中<br> PROPAGATION_REQUIRES_NEW   总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。<br> PROPAGATION_NOT_SUPPORTED    总是非事务地执行，并挂起任何存在的事务。<br> PROPAGATION_NEVER    总是非事务地执行，如果存在一个活动事务，则抛出异常<br> PROPAGATION_NESTED   如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</p><p><strong>事务传播行为种类：</strong></p><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播：<br> 下表为事务传播行为类型</p><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-07：缓存</title>
      <link href="/2022/05/10/Mybatis/MyBatis-07%EF%BC%9A%E7%BC%93%E5%AD%98/"/>
      <url>/2022/05/10/Mybatis/MyBatis-07%EF%BC%9A%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-07：缓存"><a href="#MyBatis-07：缓存" class="headerlink" title="MyBatis-07：缓存"></a>MyBatis-07：缓存</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li> 什么是缓存 [ Cache ]？ </li></ol><ul><li> 存在内存中的临时数据。 </li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件) 查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  </li></ul><ol start="2"><li> 为什么使用缓存？  </li></ol><ul><li> 减少和数据库的交互次数，减少系统开销，提高系统效率。 </li></ul><ol start="3"><li> 什么样的数据能使用缓存？ </li></ol><ul><li> 经常查询并且不经常改变的数据。 </li></ul><h3 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h3><ul><li> MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升 查询效率。 </li><li>MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存<ul><li> 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） </li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 </li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 </li></ul></li></ul><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p> 一级缓存也叫本地缓存： </p><ul><li> 与数据库同一次会话期间查询到的数据会放在本地缓存中。  </li><li> 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； </li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p> 在mybatis中加入日志，方便测试结果 </p></li><li><p> 编写接口方法  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据id查询用户</span><br><span class="line">User queryUserById(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure><ol start="3"><li> 接口对应的Mapper文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">User user2 = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 结果分析  </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVmoe1.png" alt="1656312401890"></p><h3 id="一级缓存失效的四种情况"><a href="#一级缓存失效的四种情况" class="headerlink" title="一级缓存失效的四种情况"></a>一级缓存失效的四种情况</h3><p> 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； </p><p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ </p><ol><li> sqlSession不同 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">SqlSession session2 = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">User user2 = mapper2.queryUserById(1);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session.close();</span><br><span class="line">session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>观察结果：发现发送了两条SQL语句！ </code></pre><p>   结论：每个sqlSession中的缓存相互独立 </p><ol start="2"><li> sqlSession相同，查询条件不同 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">UserMapper mapper2 = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">User user2 = mapper2.queryUserById(2);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 </code></pre><ol start="3"><li><p>sqlSession相同，两次查询之间执行了增删改操作！ </p><p> 增加方法  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改用户</span><br><span class="line">int updateUser(Map map);</span><br></pre></td></tr></table></figure><pre><code>编写SQL </code></pre>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">update user set name = #&#123;name&#125; where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><pre><code>测试  </code></pre>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line">map.put(&quot;name&quot;,&quot;kuangshen&quot;);</span><br><span class="line">map.put(&quot;id&quot;,4);</span><br><span class="line">mapper.updateUser(map);</span><br><span class="line">User user2 = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>观察结果：查询在中间执行了增删改操作后，重新执行了 </code></pre><p>   结论：因为增删改操作可能会对当前数据产生影响 </p><ol start="4"><li> sqlSession相同，手动清除一级缓存 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">session.clearCache();//手动清除缓存</span><br><span class="line">User user2 = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>一级缓存就是一个map  </code></pre><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><ul><li> 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 </li><li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存； </li><li>工作机制 <ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； </li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓 存中的数据被保存到二级缓存中； </li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li> 不同的mapper查出的数据会放在自己对应的缓存（map）中； </li></ul></li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li> 开启全局缓存 【mybatis-config.xml】  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache/&gt;</span><br><span class="line">官方示例=====&gt;查看官方文档</span><br><span class="line">&lt;cache</span><br><span class="line">eviction=&quot;FIFO&quot;</span><br><span class="line">flushInterval=&quot;60000&quot;</span><br><span class="line">size=&quot;512&quot;</span><br><span class="line">readOnly=&quot;true&quot;/&gt;</span><br><span class="line">这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回</span><br><span class="line">的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</span><br></pre></td></tr></table></figure><ol start="3"><li> 代码测试 </li></ol><ul><li> 所有的实体类先实现序列化接口</li><li> 测试代码 </li></ul>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryUserById()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">SqlSession session2 = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.queryUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">session.close();</span><br><span class="line">User user2 = mapper2.queryUserById(1);</span><br><span class="line">System.out.println(user2);</span><br><span class="line">System.out.println(user==user2);</span><br><span class="line">session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li> 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 </li><li>查出的数据都会被默认先放在一级缓存中 </li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 </li></ul><h3 id="缓存原理图"><a href="#缓存原理图" class="headerlink" title="缓存原理图"></a>缓存原理图</h3><p><img src="https://s1.ax1x.com/2022/06/27/jVmTdx.png" alt="1656312775138"></p><h3 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h3><p> 第三方缓存实现–EhCache: 查看百度百科 </p><p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； </p><p>要在应用程序中使用Ehcache，需要引入依赖的jar包 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 在mapper.xml中使用对应的缓存即可 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace = “org.acme.FooMapper” &gt;</span><br><span class="line">&lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p> 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;</span><br><span class="line">updateCheck=&quot;false&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span><br><span class="line">user.home – 用户主目录</span><br><span class="line">user.dir – 用户当前工作目录</span><br><span class="line">java.io.tmpdir – 默认临时文件路径</span><br><span class="line">--&gt;</span><br><span class="line">&lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;</span><br><span class="line">&lt;defaultCache</span><br><span class="line">eternal=&quot;false&quot;</span><br><span class="line">maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">overflowToDisk=&quot;false&quot;</span><br><span class="line">diskPersistent=&quot;false&quot;</span><br><span class="line">timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">timeToLiveSeconds=&quot;259200&quot;</span><br><span class="line">memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;cache</span><br><span class="line">name=&quot;cloud_user&quot;</span><br><span class="line">eternal=&quot;false&quot;</span><br><span class="line">maxElementsInMemory=&quot;5000&quot;</span><br><span class="line">overflowToDisk=&quot;false&quot;</span><br><span class="line">diskPersistent=&quot;false&quot;</span><br><span class="line">timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">timeToLiveSeconds=&quot;1800&quot;</span><br><span class="line">memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">name:缓存名称。</span><br><span class="line">maxElementsInMemory:缓存最大数目</span><br><span class="line">maxElementsOnDisk：硬盘最大缓存个数。</span><br><span class="line">eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span><br><span class="line">overflowToDisk:是否保存到磁盘，当系统当机时</span><br><span class="line">timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效</span><br><span class="line">时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span><br><span class="line">timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅</span><br><span class="line">当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span><br><span class="line">diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts</span><br><span class="line">of the Virtual Machine. The default value is false.</span><br><span class="line">diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应</span><br><span class="line">该有自己的一个缓冲区。</span><br><span class="line">diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span><br><span class="line">memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内</span><br><span class="line">存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span><br><span class="line">clearOnFlush：内存数量最大时是否清除。</span><br><span class="line">memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最</span><br><span class="line">少访问次数）。</span><br><span class="line">FIFO，first in first out，这个是大家最熟的，先进先出。</span><br><span class="line">LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面</span><br><span class="line">所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span><br><span class="line">LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地</span><br><span class="line">方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-06：动态SQL</title>
      <link href="/2022/05/10/Mybatis/MyBatis-06%EF%BC%9A%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2022/05/10/Mybatis/MyBatis-06%EF%BC%9A%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-06：动态SQL"><a href="#MyBatis-06：动态SQL" class="headerlink" title="MyBatis-06：动态SQL"></a>MyBatis-06：动态SQL</h1><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> <strong>什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网描述：</span><br><span class="line">MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条</span><br><span class="line">件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动</span><br><span class="line">态 SQL 这一特性可以彻底摆脱这种痛苦。</span><br><span class="line">虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL</span><br><span class="line">语言得以改进这种情形。</span><br><span class="line">动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了</span><br><span class="line">解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表</span><br><span class="line">达式来淘汰其它大部分元素。</span><br><span class="line">-------------------------------</span><br><span class="line">- if</span><br><span class="line">- choose (when, otherwise)</span><br><span class="line">- trim (where, set)</span><br><span class="line">- foreach</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure><p> 我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼 接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。 </p><p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了 开发人员的效率。 </p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p> <strong>新建一个数据库表：blog</strong> </p><p> 字段：id，title，author，create_time，views </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `blog` (</span><br><span class="line">`id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;,</span><br><span class="line">`title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;,</span><br><span class="line">`author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;,</span><br><span class="line">`create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><ol><li> 创建Mybatis基础工程 </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVm5LR.png" alt="1656310951692"></p><ol start="2"><li> IDutil工具类  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IDUtil &#123;</span><br><span class="line">public static String genId()&#123;</span><br><span class="line">return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 实体类编写 【注意set方法作用】 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class Blog &#123;</span><br><span class="line">private String id;</span><br><span class="line">private String title;</span><br><span class="line">private String author;</span><br><span class="line">private Date createTime;</span><br><span class="line">private int views;</span><br><span class="line">//set，get....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写Mapper接口及xml文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BlogMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> mybatis核心配置文件，下划线驼峰自动转换 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line">&lt;!--注册Mapper.xml--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>插入初始数据 </p><p> 编写接口 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新增一个博客</span><br><span class="line">int addBlog(Blog blog);</span><br></pre></td></tr></table></figure><pre><code>sql配置文件 </code></pre>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;</span><br><span class="line">insert into blog (id, title, author, create_time, views)</span><br><span class="line">values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><pre><code>初始化博客方法 </code></pre>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addInitBlog()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = new Blog();</span><br><span class="line">blog.setId(IDUtil.genId());</span><br><span class="line">blog.setTitle(&quot;Mybatis如此简单&quot;);</span><br><span class="line">blog.setAuthor(&quot;狂神说&quot;);</span><br><span class="line">blog.setCreateTime(new Date());</span><br><span class="line">blog.setViews(9999);</span><br><span class="line">mapper.addBlog(blog);</span><br><span class="line">blog.setId(IDUtil.genId());</span><br><span class="line">blog.setTitle(&quot;Java如此简单&quot;);</span><br><span class="line">mapper.addBlog(blog);</span><br><span class="line">blog.setId(IDUtil.genId());</span><br><span class="line">blog.setTitle(&quot;Spring如此简单&quot;);</span><br><span class="line">mapper.addBlog(blog);</span><br><span class="line">blog.setId(IDUtil.genId());</span><br><span class="line">blog.setTitle(&quot;微服务如此简单&quot;);</span><br><span class="line">mapper.addBlog(blog);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>初始化数据完毕！  </code></pre><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p> <strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询， 反之，则根据作者名来查询</strong> </p><ol><li> 编写接口类  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//需求1</span><br><span class="line">List&lt;Blog&gt; queryBlogIf(Map map);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写SQL语句 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--需求1：</span><br><span class="line">根据作者名字和博客名字来查询博客！</span><br><span class="line">如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</span><br><span class="line">select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">select * from blog where</span><br><span class="line">&lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">title = #&#123;title&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;author != null&quot;&gt;</span><br><span class="line">and author = #&#123;author&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryBlogIf()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);</span><br><span class="line">map.put(&quot;author&quot;,&quot;狂神说&quot;);</span><br><span class="line">List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);</span><br><span class="line">System.out.println(blogs);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#&#123;title&#125;,但是如果 title为空呢？那么查询语句为 select * from user where and author=#&#123;author&#125;，这是错误的 SQL 语句，如何解 决呢？请看下面的 where 语句！  </code></pre><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><p> 修改上面的SQL语句； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">select * from blog</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">title = #&#123;title&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;author != null&quot;&gt;</span><br><span class="line">and author = #&#123;author&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的 内容是以AND 或OR 开头的，则它会剔除掉。 </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p> 同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们 怎么处理呢？ </p><ol><li> 编写接口方法  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int updateBlog(Map map);</span><br></pre></td></tr></table></figure><ol start="2"><li> sql配置文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--注意set是用的逗号隔开--&gt;</span><br><span class="line">&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;</span><br><span class="line">update blog</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">title = #&#123;title&#125;,</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;author != null&quot;&gt;</span><br><span class="line">author = #&#123;author&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">where id = #&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateBlog()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(&quot;title&quot;,&quot;动态SQL&quot;);</span><br><span class="line">map.put(&quot;author&quot;,&quot;秦疆&quot;);</span><br><span class="line">map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);</span><br><span class="line">mapper.updateBlog(map);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="choose语句"><a href="#choose语句" class="headerlink" title="choose语句"></a>choose语句</h3><p> 有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标 签可以解决此类问题，类似于 Java 的 switch 语句 </p><ol><li> 编写接口方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Blog&gt; queryBlogChoose(Map map);</span><br></pre></td></tr></table></figure><ol start="2"><li> sql配置文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">select * from blog</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;choose&gt;</span><br><span class="line">&lt;when test=&quot;title != null&quot;&gt;</span><br><span class="line">title = #&#123;title&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;when test=&quot;author != null&quot;&gt;</span><br><span class="line">and author = #&#123;author&#125;</span><br><span class="line">&lt;/when&gt;</span><br><span class="line">&lt;otherwise&gt;</span><br><span class="line">and views = #&#123;views&#125;</span><br><span class="line">&lt;/otherwise&gt;</span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试类 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryBlogChoose()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;title&quot;,&quot;Java如此简单&quot;);</span><br><span class="line">map.put(&quot;author&quot;,&quot;狂神说&quot;);</span><br><span class="line">map.put(&quot;views&quot;,9999);</span><br><span class="line">List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);</span><br><span class="line">System.out.println(blogs);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p> 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出 来，然后使用时直接调用。 </p><p> <strong>提取SQL片段：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;if-title-author&quot;&gt;</span><br><span class="line">&lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">title = #&#123;title&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;author != null&quot;&gt;</span><br><span class="line">and author = #&#123;author&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure><p> <strong>引用SQL片段：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">select * from blog</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;</span><br><span class="line">&lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;</span><br><span class="line">&lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 注意： </p><ol><li> 最好基于 单表来定义 sql 片段，提高片段的可重用性 </li><li> 在 sql 片段中不要包括 where </li></ol><h3 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h3><p> 将数据库中前三个数据的id修改为1,2,3； </p><p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 </p><ol><li> 编写接口 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Blog&gt; queryBlogForeach(Map map);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写SQL语句 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;</span><br><span class="line">select * from blog</span><br><span class="line">&lt;where&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">collection:指定输入对象中的集合属性</span><br><span class="line">item:每次遍历生成的对象</span><br><span class="line">open:开始遍历时的拼接字符串</span><br><span class="line">close:结束时拼接的字符串</span><br><span class="line">separator:遍历对象之间需要拼接的字符串</span><br><span class="line">select * from blog where 1=1 and (id=1 or id=2 or id=3)</span><br><span class="line">--&gt;</span><br><span class="line">&lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">id=#&#123;id&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryBlogForeach()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">HashMap map = new HashMap();</span><br><span class="line">List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();</span><br><span class="line">ids.add(1);</span><br><span class="line">ids.add(2);</span><br><span class="line">ids.add(3);</span><br><span class="line">map.put(&quot;ids&quot;,ids);</span><br><span class="line">List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);</span><br><span class="line">System.out.println(blogs);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p> 其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-05：一对多和多对一处理</title>
      <link href="/2022/05/10/Mybatis/MyBatis-05%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/10/Mybatis/MyBatis-05%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-05：一对多和多对一处理"><a href="#MyBatis-05：一对多和多对一处理" class="headerlink" title="MyBatis-05：一对多和多对一处理"></a>MyBatis-05：一对多和多对一处理</h1><h3 id="多对一的处理"><a href="#多对一的处理" class="headerlink" title="多对一的处理"></a>多对一的处理</h3><p> 多对一的理解： </p><ul><li> 多个学生对应一个老师 </li><li>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ </li></ul><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><img src="https://s1.ax1x.com/2022/06/27/jVm4y9.png" alt="1656256260331"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` INT(10) NOT NULL,</span><br><span class="line">`name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line">INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;);</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(10) NOT NULL,</span><br><span class="line">`name` VARCHAR(30) DEFAULT NULL,</span><br><span class="line">`tid` INT(10) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `fktid` (`tid`),</span><br><span class="line">CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);</span><br></pre></td></tr></table></figure><h3 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h3><ol><li><p>  IDEA安装Lombok插件 </p></li><li><p> 引入Maven依赖 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 在代码中增加注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data //GET,SET,ToString，有参，无参构造</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">//多个学生可以是同一个老师，即多对一</span><br><span class="line">private Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写实体类对应的Mapper接口 【两个】  </li></ol><ul><li> 无论有没有需求，都应该写上，以备后来之需！ </li></ul>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface StudentMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface TeacherMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>编写Mapper接口对应的 mapper.xml配置文件 【两个】 </p><ul><li> 无论有没有需求，都应该写上，以备后来之需！  </li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="按查询嵌套处理"><a href="#按查询嵌套处理" class="headerlink" title="按查询嵌套处理"></a>按查询嵌套处理</h3><ol><li> 给StudentMapper接口增加方法</li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取所有学生及对应老师的信息</span><br><span class="line">public List&lt;Student&gt; getStudents();</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写对应的Mapper文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">需求：获取所有学生及对应老师的信息</span><br><span class="line">思路：</span><br><span class="line">1. 获取所有学生的信息</span><br><span class="line">2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span><br><span class="line">3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span><br><span class="line">1. 做一个结果集映射：StudentTeacher</span><br><span class="line">2. StudentTeacher结果集的类型为 Student</span><br><span class="line">3. 学生中老师的属性为teacher，对应数据库中为tid。</span><br><span class="line">多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span><br><span class="line">4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;</span><br><span class="line">select * from student</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="line">&lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="line">association中column多参数配置：</span><br><span class="line">column=&quot;&#123;key=value,key=value&#125;&quot;</span><br><span class="line">其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;</span><br><span class="line">select * from teacher where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p> 编写完毕去Mybatis配置文件中，注册Mapper！ </p></li><li><p> 注意点说明：  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">&lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;</span><br><span class="line">&lt;association property=&quot;teacher&quot; column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot;</span><br><span class="line">select=&quot;getTeacher&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="line">association中column多参数配置：</span><br><span class="line">column=&quot;&#123;key=value,key=value&#125;&quot;</span><br><span class="line">其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;</span><br><span class="line">select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetStudents()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = mapper.getStudents();</span><br><span class="line">for (Student student : students)&#123;</span><br><span class="line">System.out.println(</span><br><span class="line">&quot;学生名:&quot;+ student.getName()</span><br><span class="line">+&quot;\t老师:&quot;+student.getTeacher().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按结果嵌套处理"><a href="#按结果嵌套处理" class="headerlink" title="按结果嵌套处理"></a>按结果嵌套处理</h3><p>除了上面这种方式，还有其他思路吗？ </p><p>我们还可以按照结果进行嵌套处理；  </p><ol><li> 接口方法编写 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Student&gt; getStudents2();</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写对应的mapper文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">按查询结果嵌套处理</span><br><span class="line">思路：</span><br><span class="line">1. 直接查询出结果，进行结果集的映射</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;</span><br><span class="line">select s.id sid, s.name sname , t.name tname</span><br><span class="line">from student s,teacher t</span><br><span class="line">where s.tid = t.id</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;</span><br><span class="line">&lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;</span><br><span class="line">&lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span><br><span class="line">&lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p> 去mybatis-config文件中注入【此处应该处理过了】 </p></li><li><p> 测试 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetStudents2()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">List&lt;Student&gt; students = mapper.getStudents2();</span><br><span class="line">for (Student student : students)&#123;</span><br><span class="line">System.out.println(</span><br><span class="line">&quot;学生名:&quot;+ student.getName()</span><br><span class="line">+&quot;\t老师:&quot;+student.getTeacher().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>按照查询进行嵌套处理就像SQL中的子查询 </p><p>按照结果进行嵌套处理就像SQL中的联表查 </p><h3 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a>一对多处理</h3><p> 一对多的理解： </p><ul><li> 一个老师拥有多个学生 </li><li>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！ </li></ul><h3 id="实体类编写"><a href="#实体类编写" class="headerlink" title="实体类编写"></a>实体类编写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">private int tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">//一个老师多个学生</span><br><span class="line">private List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ….. 和之前一样，搭建测试的环境！ </p><h3 id="按结果嵌套处理-1"><a href="#按结果嵌套处理-1" class="headerlink" title="按结果嵌套处理"></a>按结果嵌套处理</h3><ol><li> TeacherMapper接口编写方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取指定老师，及老师下的所有学生</span><br><span class="line">public Teacher getTeacher(int id);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写接口对应的Mapper配置文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">思路:</span><br><span class="line">1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span><br><span class="line">2. 对查询出来的操作做结果集映射</span><br><span class="line">1. 集合的话，使用collection！</span><br><span class="line">JavaType和ofType都是用来指定对象类型的</span><br><span class="line">JavaType是用来指定pojo中属性的类型</span><br><span class="line">ofType指定的是映射到list集合属性中pojo的类型。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;</span><br><span class="line">select s.id sid, s.name sname , t.name tname, t.id tid</span><br><span class="line">from student s,teacher t</span><br><span class="line">where s.tid = t.id and t.id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;</span><br><span class="line">&lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;</span><br><span class="line">&lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt;</span><br><span class="line">&lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 将Mapper文件注册到MyBatis-config文件中 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetTeacher()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">TeacherMapper mapper = session.getMapper(TeacherMapper.class);</span><br><span class="line">Teacher teacher = mapper.getTeacher(1);</span><br><span class="line">System.out.println(teacher.getName());</span><br><span class="line">System.out.println(teacher.getStudents());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按查询嵌套处理-1"><a href="#按查询嵌套处理-1" class="headerlink" title="按查询嵌套处理"></a>按查询嵌套处理</h3><ol><li> TeacherMapper接口编写方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Teacher getTeacher2(int id);</span><br></pre></td></tr></table></figure><ol start="2"><li>   编写接口对应的Mapper配置文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;</span><br><span class="line">select * from teacher where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;</span><br><span class="line">&lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span><br><span class="line">&lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot;</span><br><span class="line">select=&quot;getStudentByTeacherId&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">select * from student where tid = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p> 将Mapper文件注册到MyBatis-config文件中 </p></li><li><p> 测试 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetTeacher2()&#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">TeacherMapper mapper = session.getMapper(TeacherMapper.class);</span><br><span class="line">Teacher teacher = mapper.getTeacher2(1);</span><br><span class="line">System.out.println(teacher.getName());</span><br><span class="line">System.out.println(teacher.getStudents());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p> 1、关联-association </p><p>2、集合-collection </p><p>3、所以association是用于一对一和多对一，而collection是用于一对多的关系 </p><p>4、JavaType和ofType都是用来指定对象类型的 </p><p>​    JavaType是用来指定pojo中属性的类型 </p><p>​    ofType指定的是映射到list集合属性中pojo的类型。 </p><p>注意说明： </p><p>1、保证SQL的可读性，尽量通俗易懂 </p><p>2、根据实际要求，尽量编写性能更高的SQL语句 </p><p>3、注意属性名和字段不一致的问题 </p><p>4、注意一对多和多对一 中：字段和属性对应的问题 </p><p>5、尽量使用Log4j，通过日志来查看自己的错误 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-04：使用注解开发</title>
      <link href="/2022/05/10/Mybatis/MyBatis-04%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/05/10/Mybatis/MyBatis-04%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-04：使用注解开发"><a href="#MyBatis-04：使用注解开发" class="headerlink" title="MyBatis-04：使用注解开发"></a>MyBatis-04：使用注解开发</h1><h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><ul><li><p> 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 </p></li><li><p>根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 </p></li><li><p>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个 对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； </p></li><li><p>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互， 在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思 想来编程。  </p></li></ul><p> <strong>关于接口的理解</strong> </p><ul><li> 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 </li><li>接口的本身反映了系统设计人员对系统的抽象理解。</li><li> 接口应有两类： </li><li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； </li><li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li><li> 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 </li></ul><p> <strong>三个面向区别</strong> </p><ul><li> 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . </li><li>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . </li><li>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系 统整体的架构  </li></ul><h3 id="利用注解开发"><a href="#利用注解开发" class="headerlink" title="利用注解开发"></a>利用注解开发</h3><ul><li> mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新 的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不 能用注解来构建</li><li>sql 类型主要分成 : <ul><li> @select () </li><li>@update () </li><li>@Insert () </li><li>@delete () </li></ul></li></ul><p> <strong>注意：利用注解开发就不需要mapper.xml映射文件了 .</strong> </p><ol><li> 我们在我们的接口中添加注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询全部用户</span><br><span class="line">@Select(&quot;select id,name,pwd password from user&quot;)</span><br><span class="line">public List&lt;User&gt; getAllUser();</span><br></pre></td></tr></table></figure><ol start="2"><li> 在mybatis的核心配置文件中注入 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--使用class绑定接口--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 我们去进行测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetAllUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">//本质上利用了jvm的动态代理机制</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = mapper.getAllUser();</span><br><span class="line">for (User user : users)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 利用Debug查看本质  </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVmgiT.png" alt="1656255860318"></p><ol start="5"><li> 本质上利用了jvm的动态代理机制 </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVmWz4.png" alt="1656255873810"></p><ol start="6"><li> Mybatis详细的执行流程  </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVmhQJ.png" alt="1656255894168"></p><h3 id="注解增删改"><a href="#注解增删改" class="headerlink" title="注解增删改"></a>注解增删改</h3><p> 改造MybatisUtils工具类的getSession( ) 方法，重载实现。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取SqlSession连接</span><br><span class="line">public static SqlSession getSession()&#123;</span><br><span class="line">return getSession(true); //事务自动提交</span><br><span class="line">&#125;</span><br><span class="line">public static SqlSession getSession(boolean flag)&#123;</span><br><span class="line">return sqlSessionFactory.openSession(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 【注意】确保实体类和数据库字段对应 </p><p> 查询： </p><ol><li> 编写接口方法注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据id查询用户</span><br><span class="line">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br><span class="line">User selectUserById(@Param(&quot;id&quot;) int id);</span><br></pre></td></tr></table></figure><ol start="2"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectUserById() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.selectUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 新增：  </p><ol><li> 编写接口方法注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加一个用户</span><br><span class="line">@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)</span><br><span class="line">int addUser(User user);</span><br></pre></td></tr></table></figure><ol start="2"><li> 测试  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testAddUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;);</span><br><span class="line">mapper.addUser(user);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 修改： </p><ol><li> 编写接口方法注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改一个用户</span><br><span class="line">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="line">int updateUser(User user);</span><br></pre></td></tr></table></figure><ol start="2"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);</span><br><span class="line">mapper.updateUser(user);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 删除： </p><ol><li> 编写接口方法注解 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据id删除用</span><br><span class="line">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span><br><span class="line">int deleteUser(@Param(&quot;id&quot;)int id);</span><br></pre></td></tr></table></figure><ol start="2"><li> 测试  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">mapper.deleteUser(6);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 【注意点：增删改一定记得对事务的处理】 </p><h3 id="关于-Param"><a href="#关于-Param" class="headerlink" title="关于@Param"></a>关于@Param</h3><p> @Param注解用于给方法参数起一个名字。以下是总结的使用原则： </p><ul><li> 在方法只接受一个参数的情况下，可以不使用@Param。 </li><li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li><li> 如果参数是 JavaBean ， 则不能使用@Param。 </li><li>不使用@Param注解时，参数只能有一个，并且是Javabean。  </li></ul><h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="#与$的区别"></a>#与$的区别</h3><ul><li> #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】 </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO user (name) VALUES (#&#123;name&#125;);</span><br><span class="line">INSERT INTO user (name) VALUES (?);</span><br></pre></td></tr></table></figure><ul><li> ${} 的作用是直接进行字符串替换 </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO user (name) VALUES (&#x27;$&#123;name&#125;&#x27;);</span><br><span class="line">INSERT INTO user (name) VALUES (&#x27;kuangshen&#x27;);</span><br></pre></td></tr></table></figure><p> <strong>使用注解和配置文件协同开发，才是MyBatis的最佳实践！</strong> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-03：ResultMap及分页</title>
      <link href="/2022/05/10/Mybatis/MyBatis-03%EF%BC%9AResultMap%E5%8F%8A%E5%88%86%E9%A1%B5/"/>
      <url>/2022/05/10/Mybatis/MyBatis-03%EF%BC%9AResultMap%E5%8F%8A%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-03：ResultMap及分页"><a href="#MyBatis-03：ResultMap及分页" class="headerlink" title="MyBatis-03：ResultMap及分页"></a>MyBatis-03：ResultMap及分页</h1><h3 id="查询为null问题"><a href="#查询为null问题" class="headerlink" title="查询为null问题"></a>查询为null问题</h3><p> 要解决的问题：属性名和字段名不一致 </p><p>环境：新建一个项目，将之前的项目拷贝过来 </p><ol><li> 查看之前的数据库的字段名 </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/27/jVmyd0.png" alt="1656254652835"></p><ol start="2"><li> Java中的实体类设计 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">private int id; //id</span><br><span class="line">private String name; //姓名</span><br><span class="line">private String password; //密码和数据库不一样！</span><br><span class="line">//构造</span><br><span class="line">//set/get</span><br><span class="line">//toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 接口 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据id查询用户</span><br><span class="line">User selectUserById(int id);</span><br></pre></td></tr></table></figure><ol start="4"><li> mapper映射文件  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSelectUserById() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.selectUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果: </p><ul><li><p>User{id=1, name=’狂神’, password=’null’} </p></li><li><p>查询出来发现 password 为空 . 说明出现了问题！ </p></li></ul><p>分析： </p><ul><li><p>select * from user where id = #{id} 可以看做 </p><p>select id,name,pwd from user where id = #{id} </p><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应 列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】 </p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p> 方案一：为列名指定别名 , 别名和java实体类的属性名一致 .  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">select id , name , pwd as password from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 方案二：使用结果集映射-&gt;ResultMap 【推荐】 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;</span><br><span class="line">&lt;!-- id为主键 --&gt;</span><br><span class="line">&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span><br><span class="line">&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">&lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;</span><br><span class="line">select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h3><p> <strong>自动映射</strong> </p><ul><li> resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提 取代码中解放出来。 </li><li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能 的长达数千行的代码。 </li><li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只 需要描述它们的关系就行了。 </li></ul><p> 你已经见过简单映射语句的示例了，但并没有显式指定 resultMap 。比如：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">select id , name , pwd</span><br><span class="line">from user</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况 下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 </p><p>ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。  </p><p> <strong>手动映射</strong>  </p><ol><li> 返回值类型为resultMap </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;</span><br><span class="line">select id , name , pwd from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写resultMap，实现手动映射！  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;</span><br><span class="line">&lt;!-- id为主键 --&gt;</span><br><span class="line">&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;</span><br><span class="line">&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">&lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><pre><code>如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用 到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消 化掉才是最重要的！理解结果集映射的这个概念！ </code></pre><h2 id="分页的几种方式"><a href="#分页的几种方式" class="headerlink" title="分页的几种方式"></a>分页的几种方式</h2><h3 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h3><p> 思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ </p><p>如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 </p><p>对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用 Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程 序的工具。 </p><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： </p><ul><li> SLF4J </li><li>Apache Commons Logging </li><li>Log4j 2 </li><li>Log4j </li><li>JDK logging </li></ul><p> 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查 找）。如果一个都未找到，日志功能就会被禁用。 </p><h3 id="标准日志实现"><a href="#标准日志实现" class="headerlink" title="标准日志实现"></a>标准日志实现</h3><p> 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p> 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug </p><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p> 简介：  </p><ul><li> Log4j是Apache的一个开源项目 </li><li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. </li><li>我们也可以控制每一条日志的输出格式； </li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这 些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。  </li></ul><p> 使用步骤： </p><ol><li> 导入log4j的包 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 配置文件编写  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/kuang.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure><ol start="3"><li> setting设置日志实现  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 在程序中使用Log4j进行输出！ </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意导包：org.apache.log4j.Logger</span><br><span class="line">static Logger logger = Logger.getLogger(MyTest.class);</span><br><span class="line">@Test</span><br><span class="line">public void selectUser() &#123;</span><br><span class="line">logger.info(&quot;info：进入selectUser方法&quot;);</span><br><span class="line">logger.debug(&quot;debug：进入selectUser方法&quot;);</span><br><span class="line">logger.error(&quot;error: 进入selectUser方法&quot;);</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line">for (User user: users)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 测试，看控制台输出！ </li></ol><ul><li> 使用Log4j 输出日志 </li><li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】  </li></ul><h3 id="limit实现分页"><a href="#limit实现分页" class="headerlink" title="limit实现分页"></a>limit实现分页</h3><p> <strong>思考：为什么需要分页？</strong> </p><p>在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操 作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压 力就在可控范围内。 </p><p><strong>使用Limit实现分页</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">SELECT * FROM table LIMIT stratIndex，pageSize</span><br><span class="line">SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</span><br><span class="line">#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</span><br><span class="line">SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</span><br><span class="line">#如果只给定一个参数，它表示返回最大的记录行数目：</span><br><span class="line">SELECT * FROM table LIMIT 5; //检索前 5 个记录行</span><br><span class="line">#换句话说，LIMIT n 等价于 LIMIT 0,n。</span><br></pre></td></tr></table></figure><p> 步骤： </p><ol><li> 修改Mapper文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>   Mapper接口，参数为map  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//选择全部用户实现分页</span><br><span class="line">List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);</span><br></pre></td></tr></table></figure><ol start="3"><li> 在测试类中传入参数测试 </li></ol><ul><li> 推断：起始位置 = （当前页面 - 1 ） * 页面大小 </li></ul>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分页查询 , 两个参数startIndex , pageSize</span><br><span class="line">@Test</span><br><span class="line">public void testSelectUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">int currentPage = 1; //第几页</span><br><span class="line">int pageSize = 2; //每页显示几个</span><br><span class="line">Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);</span><br><span class="line">map.put(&quot;pageSize&quot;,pageSize);</span><br><span class="line">List&lt;User&gt; users = mapper.selectUser(map);</span><br><span class="line">for (User user: users)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h3><p> 我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式 作为了解即可。我们来看下如何实现的！ </p><p>步骤： </p><ol><li> mapper接口</li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//选择全部用户RowBounds实现分页</span><br><span class="line">List&lt;User&gt; getUserByRowBounds();</span><br></pre></td></tr></table></figure><ol start="2"><li> mapper文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>测试类 </p><p> 在这里，我们需要使用RowBounds类 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUserByRowBounds() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">int currentPage = 2; //第几页</span><br><span class="line">int pageSize = 2; //每页显示几个</span><br><span class="line">RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize);</span><br><span class="line">//通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]</span><br><span class="line">List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;,</span><br><span class="line">null, rowBounds);</span><br><span class="line">for (User user: users)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件：</p><p><img src="https://s1.ax1x.com/2022/06/27/jVm2JU.png" alt="1656255619546"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-02：CRUD操作及配置解析</title>
      <link href="/2022/05/10/Mybatis/MyBatis-02%EF%BC%9ACRUD%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/05/10/Mybatis/MyBatis-02%EF%BC%9ACRUD%E6%93%8D%E4%BD%9C%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-02：CRUD操作及配置解析"><a href="#MyBatis-02：CRUD操作及配置解析" class="headerlink" title="MyBatis-02：CRUD操作及配置解析"></a>MyBatis-02：CRUD操作及配置解析</h1><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ol><li>  将上面案例中的UserMapper接口改名为 UserDao；  </li><li> 将UserMapper.xml中的namespace改为为UserDao的路径 </li><li> 再次测试 </li></ol><p> 结论：  </p><p> 配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！ </p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>select标签是mybatis中最常用的标签之一 </li><li>select语句有很多属性可以详细配置每一条SQL语句  <ul><li> SQL语句返回值类型。【完整的类名或者别名】 </li><li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 </li><li>命名空间中唯一的标识符 </li><li>接口中的方法名与映射文件中的SQL语句ID 一一对应 </li><li>id </li><li>parameterType </li><li>resultType  </li></ul></li></ul><p> 需求：根据id查询用户  </p><ol><li> 在UserMapper中添加对应方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">//查询全部用户</span><br><span class="line">List&lt;User&gt; selectUser();</span><br><span class="line">//根据id查询用户</span><br><span class="line">User selectUserById(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 在UserMapper.xml中添加Select语句 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试类中测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void tsetSelectUserById() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.selectUserById(1);</span><br><span class="line">System.out.println(user);</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 课堂练习：根据 密码 和 名字 查询用户 </p><p> 思路一：直接在方法中传递参数 </p><ol><li><p> 在接口方法的参数前加 @Param属性 </p></li><li><p> Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过密码和名字查询用户</span><br><span class="line">User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);</span><br><span class="line">/*</span><br><span class="line">&lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p> 思路二：<strong>使用万能的Map</strong> </p><ol><li> 在接口方法中，参数直接传递Map； </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User selectUserByNP2(Map&lt;String,Object&gt; map);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写sql语句的时候，需要传递参数类型，参数类型为map </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;username&quot;,&quot;小明&quot;);</span><br><span class="line">map.put(&quot;pwd&quot;,&quot;123456&quot;);</span><br><span class="line">User user = mapper.selectUserByNP2(map);</span><br></pre></td></tr></table></figure><p> <strong>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可</strong> </p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>我们一般使用insert标签进行插入操作，它的配置和select标签差不多！ </p><p>需求：给数据库增加一个用户 </p><ol><li> 在UserMapper接口中添加对应的方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加一个用户</span><br><span class="line">int addUser(User user);</span><br></pre></td></tr></table></figure><ol start="2"><li> 在UserMapper.xml中添加insert语句 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testAddUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);</span><br><span class="line">int i = mapper.addUser(user);</span><br><span class="line">System.out.println(i);</span><br><span class="line">session.commit(); //提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>**注意点：增、删、改操作需要提交事务！** </code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>我们一般使用update标签进行更新操作，它的配置和select标签差不多！ </p><p>需求：修改用户的信息 </p><ol><li> 同理，编写接口方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改一个用户</span><br><span class="line">int updateUser(User user);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写对应的配置文件SQL </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testUpdateUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">User user = mapper.selectUserById(1);</span><br><span class="line">user.setPwd(&quot;asdfgh&quot;);</span><br><span class="line">int i = mapper.updateUser(user);</span><br><span class="line">System.out.println(i);</span><br><span class="line">session.commit(); //提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p> 我们一般使用delete标签进行删除操作，它的配置和select标签差不多！ </p><p>需求：根据id删除一个用户  </p><ol><li> 同理，编写接口方法 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据id删除用户</span><br><span class="line">int deleteUser(int id);</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写对应的配置文件SQL </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">delete from user where id = #&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDeleteUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">int i = mapper.deleteUser(5);</span><br><span class="line">System.out.println(i);</span><br><span class="line">session.commit(); //提交事务,重点!不写的话不会提交到数据库</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li> 所有的增删改操作都需要提交事务！ </li><li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ </li><li>有时候根据业务的需求，可以考虑使用map传递参数！ </li><li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！ </li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p> 模糊查询like语句该怎么写? </p><p>第1种：在Java代码中添加sql通配符。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string wildcardname = “%smi%”;</span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line">&lt;select id=”selectlike”&gt;</span><br><span class="line">select * from foo where bar like #&#123;value&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 第2种：在sql语句中拼接通配符，会引起sql注入 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string wildcardname = “smi”;</span><br><span class="line">list&lt;name&gt; names = mapper.selectlike(wildcardname);</span><br><span class="line">&lt;select id=”selectlike”&gt;</span><br><span class="line">select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul><li> mybatis-config.xml 系统核心配置文件 </li><li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 </li><li>能配置的内容如下： </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br><span class="line">&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</span><br></pre></td></tr></table></figure><p> 我们可以阅读 mybatis-config.xml 上面的dtd的头文件！ </p><h3 id="environments元素"><a href="#environments元素" class="headerlink" title="environments元素"></a>environments元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">&lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/transactionManager&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure><ul><li><p> 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境 （通过default指定） </p></li><li><p>子元素节点：environment  </p><ul><li><p> dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 </p></li><li><p>数据源是必须配置的。 </p></li><li><p>有三种内建的数据源类型 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） </span><br></pre></td></tr></table></figure></li><li><p>unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 </p></li><li><p>pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应 用快速响应请求的流行处理方式。 </p></li><li><p>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外 部配置数据源，然后放置一个 JNDI上下文的引用。 </p></li><li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. </p></li><li><p>详情：点击查看官方文档 </p></li><li><p>这两种事务管理器类型都不需要设置任何属性。 </p></li><li><p>具体的一套环境，通过设置id进行区别，id保证唯一！ </p></li><li><p>子元素节点：transactionManager - [ 事务管理器 ]  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 语法 --&gt;</span><br><span class="line">&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子元素节点：数据源（dataSource）  </p></li></ul></li></ul><h3 id="mappers元素"><a href="#mappers元素" class="headerlink" title="mappers元素"></a>mappers元素</h3><p> <strong>mappers</strong>  </p><ul><li> 映射器 : 定义映射SQL语句文件 </li><li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要 告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方 式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符 （包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之 前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口 映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 </li></ul><p> <strong>引入资源方式</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用完全限定资源定位符（URL） --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">使用映射器接口实现类的完全限定类名</span><br><span class="line">需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">将包内的映射器接口实现全部注册为映射器</span><br><span class="line">但是需要配置文件名称和接口名称一致，并且位于同一目录下</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><p> <strong>Mapper文件</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ul><li> namespace中文意思：命名空间，作用如下： </li><li> namespace的命名必须跟某个接口同名 </li><li>接口中的方法与映射文件中sql语句id应该一一对应 </li><li><ol><li>namespace和子元素的id联合保证唯一 , 区别不同的mapper </li><li>绑定DAO接口</li><li>namespace命名规则 : 包名+类名  </li></ol></li></ul><p> MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显 得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。 MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 </p><h3 id="Properties优化"><a href="#Properties优化" class="headerlink" title="Properties优化"></a>Properties优化</h3><p> 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档 </p><p>我们来优化我们的配置文件 </p><p>第一步 ; 在资源目录下新建一个db.properties  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br></pre></td></tr></table></figure><p> 第二步 : 将文件导入properties 配置文件 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--导入properties文件--&gt;</span><br><span class="line">&lt;properties resource=&quot;db.properties&quot;/&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p> 更多操作，可以查看官方文档！【演示带领学习】 </p><ul><li> 配置文件优先级问题 </li><li>新特性：使用占位符 </li></ul><h3 id="typeAliases优化"><a href="#typeAliases优化" class="headerlink" title="typeAliases优化"></a>typeAliases优化</h3><p> 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定 名的冗余。  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--配置别名,注意顺序--&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p> 当这样配置时， User 可以用在任何使用 com.kuang.pojo.User 的地方。 </p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;package name=&quot;com.kuang.pojo&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><p> 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定 类名来作为它的别名。 </p><p>若有注解，则别名为其注解值。见下面的例子： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Alias(&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 去官网查看一下Mybatis默认的一些类型别名！ </p><h3 id="其他配置浏览"><a href="#其他配置浏览" class="headerlink" title="其他配置浏览"></a>其他配置浏览</h3><p> <strong>设置</strong> </p><ul><li><p> 设置（settings）相关 =&gt; 查看帮助文档 </p></li><li><p>懒加载 </p></li><li><p>日志实现 </p></li><li><p>缓存开启关闭</p></li><li><p> 一个配置完整的 settings 元素的示例如下：  </p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;</span><br><span class="line">&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p> <strong>类型处理器</strong> </p><ul><li> 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值 时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li><li> 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 </li></ul><p> <strong>对象工厂</strong> </p><ul><li> MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 </li><li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通 过有参构造方法来实例化。 </li><li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 </li></ul><h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p> <strong>作用域（Scope）和生命周期</strong> </p><p> 理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发 问题。 </p><p>我们可以先画一个流程图，分析一下Mybatis的执行过程！  </p><p><img src="https://s1.ax1x.com/2022/06/27/jVm6oV.png" alt="1656254349159"></p><p> <strong>作用域理解</strong> </p><ul><li> SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后， SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要 让其长期存在。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方 法变量）。 </li><li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的 应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以 可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。 </li><li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库 连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li><li> 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 SqlSessionFactory 的最佳作用域是应用作用域。 </li><li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接 （Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方 法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接， 让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。 </li><li>所以 SqlSession 的最佳的作用域是请求或方法作用域。  </li></ul><p><img src="https://s1.ax1x.com/2022/06/27/jVmRWF.png" alt="1656254491306"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-01：第一个程序</title>
      <link href="/2022/05/10/Mybatis/MyBatis-01%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/05/10/Mybatis/MyBatis-01%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-01：第一个程序"><a href="#MyBatis-01：第一个程序" class="headerlink" title="MyBatis-01：第一个程序"></a>MyBatis-01：第一个程序</h1><h3 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h3><ul><li> MyBatis 是一款优秀的持久层框架 </li><li><strong>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</strong> </li><li><strong>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</strong> </li><li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名 为MyBatis 。 </li><li>2013年11月迁移到Github . </li><li>Mybatis官方文档 : <a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a> </li><li>GitHub : <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a>  </li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p> <strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong> </p><ul><li> 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存 中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 </li><li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li><li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。  </li></ul><p> <strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong> </p><ul><li> 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还 无法保证内存永不掉电。 </li><li>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需 要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持 久化来缓存到外存。 </li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p> <strong>什么是持久层？</strong> </p><ul><li> 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 </li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化， 而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。 </li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可 少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况 并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. </li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】  </li></ul><h3 id="为什么需要Mybatis"><a href="#为什么需要Mybatis" class="headerlink" title="为什么需要Mybatis"></a>为什么需要Mybatis</h3><ul><li> Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . </li><li>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . </li><li>MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射 </li><li>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分， 只有使用这个技术的人有高低之别</li><li>MyBatis的优点  <ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映 射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和 实现。 </li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理 和优化。通过sql语句可以满足操作数据库的所有需求。 </li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清 晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 </li><li>提供xml标签，支持编写动态sql。 ……. </li></ul></li></ul><h2 id="MyBatis第一个程序"><a href="#MyBatis第一个程序" class="headerlink" title="MyBatis第一个程序"></a>MyBatis第一个程序</h2><p> <strong>思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试</strong> </p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ol><li> 搭建实验数据库  </li></ol>   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis`;</span><br><span class="line">USE `mybatis`;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`pwd` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">user</span>`(`id`,`name`,`pwd`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;狂神&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;abcdef&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;李</span></span><br><span class="line"><span class="string">四&#x27;</span>,<span class="string">&#x27;987654&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li> 导入MyBatis相关 jar 包 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li> 编写MyBatis核心配置文件 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?</span><br><span class="line">useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;/dataSource&gt;</span><br><span class="line">&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写MyBatis工具类  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class MybatisUtils &#123;</span><br><span class="line">private static SqlSessionFactory sqlSessionFactory;</span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//获取SqlSession连接</span><br><span class="line">public static SqlSession getSession()&#123;</span><br><span class="line">return sqlSessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 创建实体类 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">private int id; //id</span><br><span class="line">private String name; //姓名</span><br><span class="line">private String pwd; //密码</span><br><span class="line">//构造,有参,无参</span><br><span class="line">//set/get</span><br><span class="line">//toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 编写Mapper接口类 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.kuang.pojo.User;</span><br><span class="line">import java.util.List;</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">List&lt;User&gt; selectUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>编写Mapper.xml配置文件 </p><p> <strong>namespace 十分重要，不能写错！</strong> </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt;</span><br><span class="line">&lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;</span><br><span class="line">select * from user</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li> 编写测试类 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">@Test</span><br><span class="line">public void selectUser() &#123;</span><br><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line">//方法一:</span><br><span class="line">//List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);</span><br><span class="line">//方法二:</span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = mapper.selectUser();</span><br><span class="line">for (User user: users)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li> 运行测试，成功的查询出来的我们的数据，ok！ </li></ol><h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><p> <strong>可能出现问题说明：Maven静态资源过滤问题</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p> <strong>有了MyBatis以后再也不用写原生的JDBC代码了！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-08：拦截器+文件上传下载</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-08%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8+%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-08%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8+%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-08：拦截器-文件上传下载"><a href="#SpringMVC-08：拦截器-文件上传下载" class="headerlink" title="SpringMVC-08：拦截器+文件上传下载"></a>SpringMVC-08：拦截器+文件上传下载</h1><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><h4 id="概述-："><a href="#概述-：" class="headerlink" title="概述 ："></a>概述 ：</h4><p> SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行<strong>预处理和后处理</strong>。开发者 可以自己定义一些拦截器来实现特定的功能。 </p><p>过滤器与拦截器的区别：<strong>拦截器是AOP思想的具体应用</strong>。 </p><p><strong>过滤器</strong> </p><ul><li> servlet规范中的一部分，任何java web工程都可以使用 </li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 </li></ul><p> <strong>拦截器</strong> </p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 </li><li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 </li></ul><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p> 那如何实现拦截器呢？ </p><p>想要自定义拦截器，<strong>必须实现 HandlerInterceptor 接口。</strong>  </p><ol><li><p> 新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 </p></li><li><p> 配置web.xml 和 springmvc-servlet.xml 文件 </p></li><li><p> 编写一个拦截器 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.interceptor;</span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">//在请求处理的方法之前执行</span><br><span class="line">//如果返回true执行下一个拦截器</span><br><span class="line">//如果返回false就不执行下一个拦截器</span><br><span class="line">public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse</span><br><span class="line">httpServletResponse, Object o) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;------------处理前------------&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//在请求处理方法执行之后执行</span><br><span class="line">public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse</span><br><span class="line">httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;------------处理后------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//在dispatcherServlet处理后执行,做清理工作.</span><br><span class="line">public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse</span><br><span class="line">httpServletResponse, Object o, Exception e) throws Exception &#123;</span><br><span class="line">System.out.println(&quot;------------清理------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 在springmvc的配置文件中配置拦截器 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--关于拦截器的配置--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">&lt;mvc:interceptor&gt;</span><br><span class="line">&lt;!--/** 包括路径及其子路径--&gt;</span><br><span class="line">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span><br><span class="line">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span><br><span class="line">&lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">&lt;!--bean配置的就是拦截器--&gt;</span><br><span class="line">&lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt;</span><br><span class="line">&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 编写一个Controller，接收请求 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">//测试拦截器的控制器</span><br><span class="line">@Controller</span><br><span class="line">public class InterceptorController &#123;</span><br><span class="line">@RequestMapping(&quot;/interceptor&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String testFunction() &#123;</span><br><span class="line">System.out.println(&quot;控制器中的方法执行了&quot;);</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 前端 index.jsp  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/interceptor&quot;&gt;拦截器测试&lt;/a&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li> 启动tomcat 测试一下！ </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/22/j9tpWD.png" alt="1655896441426"></p><h4 id="验证用户是否登录-认证用户"><a href="#验证用户是否登录-认证用户" class="headerlink" title="验证用户是否登录 (认证用户)"></a>验证用户是否登录 (认证用户)</h4><p> <strong>实现思路</strong> </p><ol><li> 有一个登陆页面，需要写一个controller访问页面。 </li><li> 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向 session中写入用户信息。返回登陆成功。 </li><li> 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 </li></ol><p><strong>测试：</strong></p><ol><li> 编写一个登陆页面 login.jsp </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1&gt;登录页面&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot;&gt;</span><br><span class="line">用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;</span><br><span class="line">密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写一个Controller处理请求 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">//跳转到登陆页面</span><br><span class="line">@RequestMapping(&quot;/jumplogin&quot;)</span><br><span class="line">public String jumpLogin() throws Exception &#123;</span><br><span class="line">return &quot;login&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//跳转到成功页面</span><br><span class="line">@RequestMapping(&quot;/jumpSuccess&quot;)</span><br><span class="line">public String jumpSuccess() throws Exception &#123;</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//登陆提交</span><br><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">public String login(HttpSession session, String username, String pwd) throws Exception &#123;</span><br><span class="line">// 向session记录用户身份信息</span><br><span class="line">System.out.println(&quot;接收前端===&quot;+username);</span><br><span class="line">session.setAttribute(&quot;user&quot;, username);</span><br><span class="line">return &quot;success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//退出登陆</span><br><span class="line">@RequestMapping(&quot;logout&quot;)</span><br><span class="line">public String logout(HttpSession session) throws Exception &#123;</span><br><span class="line">// session 过期</span><br><span class="line">session.invalidate();</span><br><span class="line">return &quot;login&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 编写一个登陆成功的页面 success.jsp </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录成功页面&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">$&#123;user&#125;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;%--登录--%&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 编写用户登录拦截器</li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.interceptor;</span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object</span><br><span class="line">handler) throws ServletException, IOException &#123;</span><br><span class="line">// 如果是登陆页面则放行</span><br><span class="line">System.out.println(&quot;uri: &quot; + request.getRequestURI());</span><br><span class="line">if (request.getRequestURI().contains(&quot;login&quot;)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">// 如果用户已登陆也放行</span><br><span class="line">if(session.getAttribute(&quot;user&quot;) != null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">// 用户没有登陆跳转到登陆页面</span><br><span class="line">request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse</span><br><span class="line">httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse</span><br><span class="line">httpServletResponse, Object o, Exception e) throws Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 在Springmvc的配置文件中<strong>注册拦截器</strong> </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--关于拦截器的配置--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">&lt;mvc:interceptor&gt;</span><br><span class="line">&lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt;</span><br><span class="line">&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li> 再次重启Tomcat测试！ </li></ol><p> OK，测试登录拦截功能无误.  </p><h3 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p> 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中 默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传 功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/formdata。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； </p><p>对表单中的 enctype 属性做个详细的说明： </p><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的 表单会将表单域中的值处理成 URL 编码方式。 </li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定 文件的内容也封装到请求参数中，不会对字符编码。 </li><li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮 件。 </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p> 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上 传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的 Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 </p><ul><li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 </li><li>而Spring MVC则提供了更简单的封装。 </li><li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li><li> Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类： </li><li>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的 组件。 </li></ul><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><ol><li> 导入文件上传的<strong>jar包，commons-fileupload ， Maven</strong>会自动帮我们导入他的依赖包 commons-io包； </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--servlet-api导入高版本的--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置bean：<strong>multipartResolver</strong>  </p><p> 【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里 栽过坑,教训！】 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--文件上传配置--&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot;</span><br><span class="line">class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span><br><span class="line">&lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;</span><br><span class="line">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span><br><span class="line">&lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><pre><code>CommonsMultipartFile 的 常用方法：  </code></pre><ul><li> String getOriginalFilename()：获取上传文件的原名 </li><li>InputStream getInputStream()：获取文件流 </li><li>void transferTo(File dest)：将上传文件保存到一个目录文件中 </li></ul><ol start="3"><li> 编写前端页面 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> Controller  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.multipart.commons.CommonsMultipartFile;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.*;</span><br><span class="line">@Controller</span><br><span class="line">public class FileController &#123;</span><br><span class="line">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span><br><span class="line">//批量上传CommonsMultipartFile则为数组即可</span><br><span class="line">@RequestMapping(&quot;/upload&quot;)</span><br><span class="line">public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file ,</span><br><span class="line">HttpServletRequest request) throws IOException &#123;</span><br><span class="line">//获取文件名 : file.getOriginalFilename();</span><br><span class="line">String uploadFileName = file.getOriginalFilename();</span><br><span class="line">//如果文件名为空，直接回到首页！</span><br><span class="line">if (&quot;&quot;.equals(uploadFileName))&#123;</span><br><span class="line">return &quot;redirect:/index.jsp&quot;;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;上传文件名 : &quot;+uploadFileName);</span><br><span class="line">//上传路径保存设置</span><br><span class="line">String path = request.getServletContext().getRealPath(&quot;/upload&quot;);</span><br><span class="line">//如果路径不存在，创建一个</span><br><span class="line">File realPath = new File(path);</span><br><span class="line">if (!realPath.exists())&#123;</span><br><span class="line">realPath.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;上传文件保存地址：&quot;+realPath);</span><br><span class="line">InputStream is = file.getInputStream(); //文件输入流</span><br><span class="line">OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流</span><br><span class="line">//读取写出</span><br><span class="line">int len=0;</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">while ((len=is.read(buffer))!=-1)&#123;</span><br><span class="line">os.write(buffer,0,len);</span><br><span class="line">os.flush();</span><br><span class="line">&#125;</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">return &quot;redirect:/index.jsp&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>采用file.Transto 来保存上传的文件</strong> </p><ol><li> 编写Controller  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 采用file.Transto 来保存上传的文件</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(&quot;/upload2&quot;)</span><br><span class="line">public String fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file,</span><br><span class="line">HttpServletRequest request) throws IOException &#123;</span><br><span class="line">//上传路径保存设置</span><br><span class="line">String path = request.getServletContext().getRealPath(&quot;/upload&quot;);</span><br><span class="line">File realPath = new File(path);</span><br><span class="line">if (!realPath.exists())&#123;</span><br><span class="line">realPath.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">//上传文件地址</span><br><span class="line">System.out.println(&quot;上传文件保存地址：&quot;+realPath);</span><br><span class="line">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span><br><span class="line">file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));</span><br><span class="line">return &quot;redirect:/index.jsp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p> 前端表单提交地址修改 </p></li><li><p> 访问提交测试，OK！ </p></li></ol><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p> <strong>文件下载步骤：</strong> </p><ol><li> 设置 response 响应头 </li><li> 读取文件 – InputStream </li><li> 写出文件 – OutputStream  </li><li> 执行操作 </li><li> 关闭流 （先开后关） </li></ol><p> <strong>代码实现：</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/download&quot;)</span><br><span class="line">public String downloads(HttpServletResponse response ,HttpServletRequest request) throws</span><br><span class="line">Exception&#123;</span><br><span class="line">//要下载的图片地址</span><br><span class="line">String path = request.getServletContext().getRealPath(&quot;/upload&quot;);</span><br><span class="line">String fileName = &quot;基础语法.jpg&quot;;</span><br><span class="line">//1、设置response 响应头</span><br><span class="line">response.reset(); //设置页面不缓存,清空buffer</span><br><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码</span><br><span class="line">response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据</span><br><span class="line">//设置响应头</span><br><span class="line">response.setHeader(&quot;Content-Disposition&quot;,</span><br><span class="line">&quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));</span><br><span class="line">File file = new File(path,fileName);</span><br><span class="line">//2、 读取文件--输入流</span><br><span class="line">InputStream input=new FileInputStream(file);</span><br><span class="line">//3、 写出文件--输出流</span><br><span class="line">OutputStream out = response.getOutputStream();</span><br><span class="line">byte[] buff =new byte[1024];</span><br><span class="line">int index=0;</span><br><span class="line">//4、执行 写出操作</span><br><span class="line">while((index= input.read(buff))!= -1)&#123;</span><br><span class="line">out.write(buff, 0, index);</span><br><span class="line">out.flush();</span><br><span class="line">&#125;</span><br><span class="line">out.close();</span><br><span class="line">input.close();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 前端 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p> 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了! </p><p><strong>结论：</strong></p><p> 拦截器及文件操作在我们开发中十分重要，一定要学会使用！ </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-07：Ajax研究</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-07%EF%BC%9AAjax%E7%A0%94%E7%A9%B6/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-07%EF%BC%9AAjax%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-07：Ajax研究"><a href="#SpringMVC-07：Ajax研究" class="headerlink" title="SpringMVC-07：Ajax研究"></a>SpringMVC-07：Ajax研究</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 </li><li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 </li><li>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的 技术。 </li><li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完 成搜索单词。 </li><li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时， JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 </li><li>就和国内百度的搜索框一样! </li><li>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 </li><li>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li><li> 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 </li></ul><h4 id="伪造Ajax"><a href="#伪造Ajax" class="headerlink" title="伪造Ajax"></a>伪造Ajax</h4><p> 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 </p><ol><li><p> 新建一个module ：sspringmvc-06-ajax ， 导入web支持！ </p></li><li><p> 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">var myDate = new Date();</span><br><span class="line">document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime();</span><br><span class="line">&#125;;</span><br><span class="line">function LoadPage()&#123;</span><br><span class="line">var targetUrl = document.getElementById(&#x27;url&#x27;).value;</span><br><span class="line">console.log(targetUrl);</span><br><span class="line">document.getElementById(&quot;iframePosition&quot;).src = targetUrl;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;加载页面位置：&lt;/h3&gt;</span><br><span class="line">&lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用IDEA开浏览器测试一下！ </p><p> 利用AJAX可以做： </p></li></ol><ul><li> 注册时，输入用户名自动检测用户是否已经存在。 </li><li>登陆时，提示用户名密码错误 </li><li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行 也删除。 ….等等  </li></ul><h4 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery.ajax"></a>jQuery.ajax</h4><p> 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣 的同学可以去了解下JS原生XMLHttpRequest ！ </p><p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以 异步方式从服务器获取新数据。 </p><p>jQuery 提供多个与 AJAX 有关的方法。 </p><p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p><p>jQuery 不是生产者，而是大自然搬运工。 </p><p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery.ajax(...)</span><br><span class="line">部分参数：</span><br><span class="line">url：请求地址</span><br><span class="line">type：请求方式，GET、POST（1.9.0之后用method）</span><br><span class="line">headers：请求头</span><br><span class="line">data：要发送的数据</span><br><span class="line">contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded;</span><br><span class="line">charset=UTF-8&quot;)</span><br><span class="line">async：是否异步</span><br><span class="line">timeout：设置请求超时时间（毫秒）</span><br><span class="line">beforeSend：发送请求前执行的函数(全局)</span><br><span class="line">complete：完成之后执行的回调函数(全局)</span><br><span class="line">success：成功之后执行的回调函数(全局)</span><br><span class="line">error：失败之后执行的回调函数(全局)</span><br><span class="line">accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型</span><br><span class="line">dataType：将服务器端返回的数据转换成指定类型</span><br><span class="line">&quot;xml&quot;: 将服务器端返回的内容转换成xml格式</span><br><span class="line">&quot;text&quot;: 将服务器端返回的内容转换成普通文本格式</span><br><span class="line">&quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会</span><br><span class="line">尝试去执行。</span><br><span class="line">&quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式</span><br><span class="line">&quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class="line">&quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ?</span><br><span class="line">为正确的函数名，以执行回调函数</span><br></pre></td></tr></table></figure><p> 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 </p><ol><li> 配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">http://www.springframework.org/schema/mvc</span><br><span class="line">https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler /&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;!-- 前缀 --&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;!-- 后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写一个AjaxController  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class AjaxController &#123;</span><br><span class="line">@RequestMapping(&quot;/a1&quot;)</span><br><span class="line">public void ajax1(String name , HttpServletResponse response) throws IOException &#123;</span><br><span class="line">if (&quot;admin&quot;.equals(name))&#123;</span><br><span class="line">response.getWriter().print(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">response.getWriter().print(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 导入jquery ， 可以使用在线的CDN ， 也可以下载导入 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写index.jsp测试  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;</span><br><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function a1()&#123;</span><br><span class="line">$.post(&#123;</span><br><span class="line">url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,</span><br><span class="line">data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;,</span><br><span class="line">success:function (data,status) &#123;</span><br><span class="line">alert(data);</span><br><span class="line">alert(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--onblur：失去焦点触发事件--%&gt;</span><br><span class="line">用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请 求！是后台返回给我们的结果！测试成功！ </li></ol><h4 id="Springmvc实现"><a href="#Springmvc实现" class="headerlink" title="Springmvc实现"></a>Springmvc实现</h4><p> <strong>实体类user</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们来获取一个集合对象，展示到前端页面 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/a2&quot;)</span><br><span class="line">public List&lt;User&gt; ajax2()&#123;</span><br><span class="line">List&lt;User&gt; list = new ArrayList&lt;User&gt;();</span><br><span class="line">list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));</span><br><span class="line">list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));</span><br><span class="line">list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));</span><br><span class="line">return list; //由于@RestController注解，将list转成json格式返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 前端页面 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;</span><br><span class="line">&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">&lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">&lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tbody id=&quot;content&quot;&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(function () &#123;</span><br><span class="line">$(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">$.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;</span><br><span class="line">console.log(data)</span><br><span class="line">var html=&quot;&quot;;</span><br><span class="line">for (var i = 0; i &lt;data.length ; i++) &#123;</span><br><span class="line">html+= &quot;&lt;tr&gt;&quot; +</span><br><span class="line">&quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +</span><br><span class="line">&quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +</span><br><span class="line">&quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +</span><br><span class="line">&quot;&lt;/tr&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line">$(&quot;#content&quot;).html(html);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> 成功实现了数据回显！可以体会一下Ajax的好处！ </p><h4 id="注册提示效果"><a href="#注册提示效果" class="headerlink" title="注册提示效果"></a>注册提示效果</h4><p> 我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/a3&quot;)</span><br><span class="line">public String ajax3(String name,String pwd)&#123;</span><br><span class="line">String msg = &quot;&quot;;</span><br><span class="line">//模拟数据库中存在数据</span><br><span class="line">if (name!=null)&#123;</span><br><span class="line">if (&quot;admin&quot;.equals(name))&#123;</span><br><span class="line">msg = &quot;OK&quot;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">msg = &quot;用户名输入错误&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (pwd!=null)&#123;</span><br><span class="line">if (&quot;123456&quot;.equals(pwd))&#123;</span><br><span class="line">msg = &quot;OK&quot;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">msg = &quot;密码输入有误&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return msg; //由于@RestController注解，将msg转成json格式返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 前端页面 login.jsp </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;ajax&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function a1()&#123;</span><br><span class="line">$.post(&#123;</span><br><span class="line">url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,</span><br><span class="line">data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;,</span><br><span class="line">success:function (data) &#123;</span><br><span class="line">if (data.toString()==&#x27;OK&#x27;)&#123;</span><br><span class="line">$(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">$(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);</span><br><span class="line">&#125;</span><br><span class="line">$(&quot;#userInfo&quot;).html(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function a2()&#123;</span><br><span class="line">$.post(&#123;</span><br><span class="line">url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,</span><br><span class="line">data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;,</span><br><span class="line">success:function (data) &#123;</span><br><span class="line">if (data.toString()==&#x27;OK&#x27;)&#123;</span><br><span class="line">$(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">$(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);</span><br><span class="line">&#125;</span><br><span class="line">$(&quot;#pwdInfo&quot;).html(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;</span><br><span class="line">&lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;</span><br><span class="line">&lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/06/22/j9tSJO.png" alt="1655895506244"></p><h4 id="获取baidu接口Demo"><a href="#获取baidu接口Demo" class="headerlink" title="获取baidu接口Demo"></a>获取baidu接口Demo</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSONP百度搜索&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#q&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 30px;</span><br><span class="line">border:1px solid #ddd;</span><br><span class="line">line-height: 30px;</span><br><span class="line">display: block;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">padding: 0 10px;</span><br><span class="line">font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">#ul&#123;</span><br><span class="line">width: 520px;</span><br><span class="line">list-style: none;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">padding: 0;</span><br><span class="line">border:1px solid #ddd;</span><br><span class="line">margin-top: -1px;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">#ul li&#123;</span><br><span class="line">line-height: 30px;</span><br><span class="line">padding: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">#ul li:hover&#123;</span><br><span class="line">background-color: #f60;</span><br><span class="line">color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 2.步骤二</span><br><span class="line">// 定义demo函数 (分析接口、数据)</span><br><span class="line">function demo(data)&#123;</span><br><span class="line">var Ul = document.getElementById(&#x27;ul&#x27;);</span><br><span class="line">var html = &#x27;&#x27;;</span><br><span class="line">// 如果搜索数据存在 把内容添加进去</span><br><span class="line">if (data.s.length) &#123;</span><br><span class="line">// 隐藏掉的ul显示出来</span><br><span class="line">Ul.style.display = &#x27;block&#x27;;</span><br><span class="line">// 搜索到的数据循环追加到li里</span><br><span class="line">for(var i = 0;i&lt;data.s.length;i++)&#123;</span><br><span class="line">html += &#x27;&lt;li&gt;&#x27;+data.s[i]+&#x27;&lt;/li&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">// 循环的li写入ul</span><br><span class="line">Ul.innerHTML = html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 1.步骤一</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">// 获取输入框和ul</span><br><span class="line">var Q = document.getElementById(&#x27;q&#x27;);</span><br><span class="line">var Ul = document.getElementById(&#x27;ul&#x27;);</span><br><span class="line">// 事件鼠标抬起时候</span><br><span class="line">Q.onkeyup = function()&#123;</span><br><span class="line">// 如果输入框不等于空</span><br><span class="line">if (this.value != &#x27;&#x27;) &#123;</span><br><span class="line">// ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line">// 创建标签</span><br><span class="line">var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">//给定要跨域的地址 赋值给src</span><br><span class="line">//这里是要请求的跨域的地址 我写的是百度搜索的跨域地址</span><br><span class="line">script.src = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?</span><br><span class="line">wd=&#x27;+this.value+&#x27;&amp;cb=demo&#x27;;</span><br><span class="line">// 将组合好的带src的script标签追加到body里</span><br><span class="line">document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;</span><br><span class="line">&lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p> Ajax在我们开发中十分重要！！！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-06：Json交互处理</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-06%EF%BC%9AJson%E4%BA%A4%E4%BA%92%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-06%EF%BC%9AJson%E4%BA%A4%E4%BA%92%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-06：Json交互处理"><a href="#SpringMVC-06：Json交互处理" class="headerlink" title="SpringMVC-06：Json交互处理"></a>SpringMVC-06：Json交互处理</h1><h3 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h3><ul><li> JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 </li><li>采用完全独立于编程语言的文本格式来存储和表示数据。</li><li> 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 </li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 </li><li>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字 符串、数字、对象、数组等。看看他的要求和语法格式： </li><li>对象表示为键值对，数据由逗号分隔 </li><li>花括号保存对象 </li><li>方括号保存数组 </li></ul><p> JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合 中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;</span><br><span class="line">&#123;&quot;age&quot;: &quot;3&quot;&#125;</span><br><span class="line">&#123;&quot;sex&quot;: &quot;男&quot;&#125;</span><br></pre></td></tr></table></figure><p> 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的</span><br><span class="line">var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串</span><br></pre></td></tr></table></figure><p> JSON 和 JavaScript 对象互转 </p><p> 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);</span><br><span class="line">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span><br></pre></td></tr></table></figure><p> 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);</span><br><span class="line">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p> 代码测试 </p><ol><li><p> 新建一个module ，springmvc-05-json ， 添加web的支持 </p></li><li><p> 在web目录下新建一个 json-1.html ， 编写测试内容 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSON_秦疆&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//编写一个js的对象</span><br><span class="line">var user = &#123;</span><br><span class="line">name:&quot;秦疆&quot;,</span><br><span class="line">age:3,</span><br><span class="line">sex:&quot;男&quot;</span><br><span class="line">&#125;;</span><br><span class="line">//将js对象转换成json字符串</span><br><span class="line">var str = JSON.stringify(user);</span><br><span class="line">console.log(str);</span><br><span class="line">//将json字符串转换为js对象</span><br><span class="line">var user2 = JSON.parse(str);</span><br><span class="line">console.log(user2.age,user2.name,user2.sex);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 在IDEA中使用浏览器打开，查看控制台输出 </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/22/j9Y7z4.png" alt="1655888591247"></p><h4 id="Controller返回JSON数据"><a href="#Controller返回JSON数据" class="headerlink" title="Controller返回JSON数据"></a>Controller返回JSON数据</h4><p> Jackson应该是目前比较好的json解析工具了 </p><p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 </p><p>我们这里使用Jackson，使用它需要导入它的jar包； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 配置SpringMVC需要的配置 </p><p>web.xml </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">version=&quot;4.0&quot;&gt;</span><br><span class="line">&lt;!--1.注册servlet--&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;!--所有请求都会被springmvc拦截 --&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;encoding&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p> springmvc-servlet.xml  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">http://www.springframework.org/schema/mvc</span><br><span class="line">https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;</span><br><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;!-- 前缀 --&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;!-- 后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p> 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">//需要导入lombok</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">private String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 </p><p>编写一个Controller；  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">@RequestMapping(&quot;/json1&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String json1() throws JsonProcessingException &#123;</span><br><span class="line">//创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//创建一个对象</span><br><span class="line">User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">//将我们的对象解析成为json格式</span><br><span class="line">String str = mapper.writeValueAsString(user);</span><br><span class="line">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置Tomcat ， 启动测试一下！</p><p> <a href="http://localhost:8080/json1">http://localhost:8080/json1</a>  </p><p><img src="https://s1.ax1x.com/2022/06/22/j9YXe1.png" alt="1655888722567"></p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p> 乱码统一解决 </p><p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不 用每次都去处理了！ </p><p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">&lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class="line">&lt;constructor-arg value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class="line">&lt;property name=&quot;objectMapper&quot;&gt;</span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;</span><br><span class="line">&lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/mvc:message-converters&gt;</span><br><span class="line">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure><p> 返回json字符串统一解决 </p><p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都 添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">//produces:指定响应体返回类型和编码</span><br><span class="line">@RequestMapping(value = &quot;/json1&quot;)</span><br><span class="line">public String json1() throws JsonProcessingException &#123;</span><br><span class="line">//创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//创建一个对象</span><br><span class="line">User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">//将我们的对象解析成为json格式</span><br><span class="line">String str = mapper.writeValueAsString(user);</span><br><span class="line">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 启动tomcat测试，结果都正常输出！ </p><h4 id="测试集合输出"><a href="#测试集合输出" class="headerlink" title="测试集合输出"></a>测试集合输出</h4><p> 增加一个新的方法  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json2&quot;)</span><br><span class="line">public String json2() throws JsonProcessingException &#123;</span><br><span class="line">//创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//创建一个对象</span><br><span class="line">User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);</span><br><span class="line">User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);</span><br><span class="line">User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);</span><br><span class="line">User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);</span><br><span class="line">List&lt;User&gt; list = new ArrayList&lt;User&gt;();</span><br><span class="line">list.add(user1);</span><br><span class="line">list.add(user2);</span><br><span class="line">list.add(user3);</span><br><span class="line">list.add(user4);</span><br><span class="line">//将我们的对象解析成为json格式</span><br><span class="line">String str = mapper.writeValueAsString(list);</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果 : 十分完美，没有任何问题！  </p><p><img src="https://s1.ax1x.com/2022/06/22/j9Yjdx.png" alt="1655890025121"></p><h4 id="输出时间对象"><a href="#输出时间对象" class="headerlink" title="输出时间对象"></a>输出时间对象</h4><p> 增加一个新的方法  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json3&quot;)</span><br><span class="line">public String json3() throws JsonProcessingException &#123;</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//创建时间一个对象，java.util.Date</span><br><span class="line">Date date = new Date();</span><br><span class="line">//将我们的对象解析成为json格式</span><br><span class="line">String str = mapper.writeValueAsString(date);</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果  ：</p><p><img src="https://s1.ax1x.com/2022/06/22/j9Yvo6.png" alt="1655890146789"></p><ul><li> 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ </li><li>Jackson 默认是会把时间转成timestamps形式  </li></ul><p> 解决方案：取消timestamps形式 ， 自定义时间格式 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json4&quot;)</span><br><span class="line">public String json4() throws JsonProcessingException &#123;</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//不使用时间戳的方式</span><br><span class="line">mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line">//自定义日期格式对象</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">//指定日期格式</span><br><span class="line">mapper.setDateFormat(sdf);</span><br><span class="line">Date date = new Date();</span><br><span class="line">String str = mapper.writeValueAsString(date);</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果 : 成功的输出了时间！ </p><p><img src="https://s1.ax1x.com/2022/06/22/j9YzFK.png" alt="1655890269934"></p><h4 id="抽取为工具类"><a href="#抽取为工具类" class="headerlink" title="抽取为工具类"></a>抽取为工具类</h4><p> 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去 编写下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.utils;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">public class JsonUtils &#123;</span><br><span class="line">public static String getJson(Object object) &#123;</span><br><span class="line">return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static String getJson(Object object,String dateFormat) &#123;</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//不使用时间差的方式</span><br><span class="line">mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);</span><br><span class="line">//自定义日期格式对象</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);</span><br><span class="line">//指定日期格式</span><br><span class="line">mapper.setDateFormat(sdf);</span><br><span class="line">try &#123;</span><br><span class="line">return mapper.writeValueAsString(object);</span><br><span class="line">&#125; catch (JsonProcessingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们使用工具类，代码就更加简洁了！ </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/json5&quot;)</span><br><span class="line">public String json5() throws JsonProcessingException &#123;</span><br><span class="line">Date date = new Date();</span><br><span class="line">String json = JsonUtils.getJson(date);</span><br><span class="line">return json;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-05：整合SSM框架</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-05%EF%BC%9A%E6%95%B4%E5%90%88SSM%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-05%EF%BC%9A%E6%95%B4%E5%90%88SSM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-05：整合SSM框架"><a href="#SpringMVC-05：整合SSM框架" class="headerlink" title="SpringMVC-05：整合SSM框架"></a>SpringMVC-05：整合SSM框架</h1><h3 id="整合SSM"><a href="#整合SSM" class="headerlink" title="整合SSM"></a>整合SSM</h3><h4 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h4><p> 环境： IDEA 、MySQL 5.7.19 、Tomcat 9、 Maven 3.6  </p><p> 要求： 需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识； </p><h4 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h4><p> 创建一个存放书籍数据的数据库表 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql:</span><br><span class="line">CREATE DATABASE `ssmbuild`;</span><br><span class="line">USE `ssmbuild`;</span><br><span class="line">DROP TABLE IF EXISTS `books`;</span><br><span class="line">CREATE TABLE `books` (</span><br><span class="line">`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,</span><br><span class="line">`bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,</span><br><span class="line">`bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;,</span><br><span class="line">`detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,</span><br><span class="line">KEY `bookID` (`bookID`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8</span><br><span class="line">INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES</span><br><span class="line">(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),</span><br><span class="line">(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),</span><br><span class="line">(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;);</span><br></pre></td></tr></table></figure><h4 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h4><ol><li><p> 新建一Maven项目！ssmbuild ， 添加web的支持 </p></li><li><p> 导入相关的pom依赖！ </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!--Junit--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--数据库驱动--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 数据库连接池 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Servlet - JSP --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Mybatis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.5.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> Maven资源过滤设置 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 建立基本结构和配置框架！</li></ol><ul><li><p> com.kuang.pojo </p></li><li><p>com.kuang.dao </p></li><li><p>com.kuang.service </p></li><li><p>com.kuang.controller </p></li><li><p>mybatis-config.xml </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p> applicationContext.xml  </p></li></ul><pre><code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure> </code></pre><h4 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h4><ol><li> 数据库配置文件 database.properties  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?</span><br><span class="line">useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root123</span><br></pre></td></tr></table></figure><ol start="2"><li><p> IDEA关联数据库  </p></li><li><p> 编写MyBatis的核心配置文件 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;package name=&quot;com.kuang.pojo&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;mapper resource=&quot;com/kuang/dao/BookMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>编写数据库对应的实体类 com.kuang.pojo.Books </p><p> 使用<strong>lombok</strong>插件！  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.pojo;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Books &#123;</span><br><span class="line">private int bookID;</span><br><span class="line">private String bookName;</span><br><span class="line">private int bookCounts;</span><br><span class="line">private String detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 编写Dao层的 Mapper接口！ </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.dao;</span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line">import java.util.List;</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">//增加一个Book</span><br><span class="line">int addBook(Books book);</span><br><span class="line">//根据id删除一个Book</span><br><span class="line">int deleteBookById(int id);</span><br><span class="line">//更新Book</span><br><span class="line">int updateBook(Books books);</span><br><span class="line">//根据id查询,返回一个Book</span><br><span class="line">Books queryBookById(int id);</span><br><span class="line">//查询全部Book,返回list集合</span><br><span class="line">List&lt;Books&gt; queryAllBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- 导入Mapper！！！！！！！！！！！！！！！！！！！！！！！！ --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt;</span><br><span class="line">&lt;!--增加一个Book--&gt;</span><br><span class="line">&lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;</span><br><span class="line">insert into ssmbuild.books(bookName,bookCounts,detail)</span><br><span class="line">values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;!--根据id删除一个Book--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">delete from ssmbuild.books where bookID=#&#123;bookID&#125;</span><br><span class="line">&lt;/delete&gt;</span><br><span class="line">&lt;!--更新Book--&gt;</span><br><span class="line">&lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt;</span><br><span class="line">update ssmbuild.books</span><br><span class="line">set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;</span><br><span class="line">where bookID = #&#123;bookID&#125;</span><br><span class="line">&lt;/update&gt;</span><br><span class="line">&lt;!--根据id查询,返回一个Book--&gt;</span><br><span class="line">&lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;</span><br><span class="line">select * from ssmbuild.books</span><br><span class="line">where bookID = #&#123;bookID&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!--查询全部Book--&gt;</span><br><span class="line">&lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt;</span><br><span class="line">SELECT * from ssmbuild.books</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li> 编写Service层的接口和实现类 </li></ol><p>   接口：</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.service;</span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line">import java.util.List;</span><br><span class="line">//BookService:底下需要去实现,调用dao层</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">//增加一个Book</span><br><span class="line">int addBook(Books book);</span><br><span class="line">//根据id删除一个Book</span><br><span class="line">int deleteBookById(int id);</span><br><span class="line">//更新Book</span><br><span class="line">int updateBook(Books books);</span><br><span class="line">//根据id查询,返回一个Book</span><br><span class="line">Books queryBookById(int id);</span><br><span class="line">//查询全部Book,返回list集合</span><br><span class="line">List&lt;Books&gt; queryAllBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   实现类：</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.service;</span><br><span class="line">import com.kuang.dao.BookMapper;</span><br><span class="line">import com.kuang.pojo.Books;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">//调用dao层的操作，设置一个set接口，方便Spring管理</span><br><span class="line">private BookMapper bookMapper;</span><br><span class="line">public void setBookMapper(BookMapper bookMapper) &#123;</span><br><span class="line">this.bookMapper = bookMapper;</span><br><span class="line">&#125;</span><br><span class="line">public int addBook(Books book) &#123;</span><br><span class="line">return bookMapper.addBook(book);</span><br><span class="line">&#125;</span><br><span class="line">public int deleteBookById(int id) &#123;</span><br><span class="line">return bookMapper.deleteBookById(id);</span><br><span class="line">&#125;</span><br><span class="line">public int updateBook(Books books) &#123;</span><br><span class="line">return bookMapper.updateBook(books);</span><br><span class="line">&#125;</span><br><span class="line">public Books queryBookById(int id) &#123;</span><br><span class="line">return bookMapper.queryBookById(id);</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Books&gt; queryAllBook() &#123;</span><br><span class="line">return bookMapper.queryAllBook();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h4><ol><li><p> 配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； </p></li><li><p> 我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="line">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="line">&lt;!--数据库连接池</span><br><span class="line">dbcp 半自动化操作 不能自动连接</span><br><span class="line">c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">&lt;!-- 配置连接池属性 --&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">&lt;!-- c3p0连接池的私有属性 --&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;</span><br><span class="line">&lt;!-- 关闭连接后不自动commit --&gt;</span><br><span class="line">&lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;!-- 获取连接超时时间 --&gt;</span><br><span class="line">&lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;</span><br><span class="line">&lt;!-- 当获取连接失败重试次数 --&gt;</span><br><span class="line">&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span><br><span class="line">&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="line">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">&lt;!-- 注入sqlSessionFactory --&gt;</span><br><span class="line">&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;</span><br><span class="line">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br><span class="line">&lt;property name=&quot;basePackage&quot; value=&quot;com.kuang.dao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> Spring整合service层 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 扫描service相关的bean --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.service&quot; /&gt;</span><br><span class="line">&lt;!--BookServiceImpl注入到IOC容器中--&gt;</span><br><span class="line">&lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.kuang.service.BookServiceImpl&quot;&gt;</span><br><span class="line">&lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;!-- 注入数据库连接池 --&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="SpringMVC层"><a href="#SpringMVC层" class="headerlink" title="SpringMVC层"></a>SpringMVC层</h4><ol><li> web.xml </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">version=&quot;4.0&quot;&gt;</span><br><span class="line">&lt;!--DispatcherServlet--&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span><br><span class="line">&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;!--encodingFilter--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;</span><br><span class="line">org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">&lt;/filter-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;!--Session过期时间--&gt;</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;15&lt;/session-timeout&gt;</span><br><span class="line">&lt;/session-config&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li> spring-mvc.xml </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">http://www.springframework.org/schema/mvc</span><br><span class="line">https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 配置SpringMVC --&gt;</span><br><span class="line">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 2.静态资源默认servlet配置--&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br><span class="line">&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 4.扫描web相关的bean --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.controller&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> Spring配置整合文件，applicationContext.xml  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;import resource=&quot;spring-dao.xml&quot;/&gt;</span><br><span class="line">&lt;import resource=&quot;spring-service.xml&quot;/&gt;</span><br><span class="line">&lt;import resource=&quot;spring-mvc.xml&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p> 配置文件，暂时结束！Controller 和 视图层编写 </p><ol><li> BookController 类编写 ， 方法一：查询全部书籍 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/book&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;BookServiceImpl&quot;)</span><br><span class="line">private BookService bookService;</span><br><span class="line">@RequestMapping(&quot;/allBook&quot;)</span><br><span class="line">public String list(Model model) &#123;</span><br><span class="line">List&lt;Books&gt; list = bookService.queryAllBook();</span><br><span class="line">model.addAttribute(&quot;list&quot;, list);</span><br><span class="line">return &quot;allBook&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 编写首页 index.jsp </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">a &#123;</span><br><span class="line">text-decoration: none;</span><br><span class="line">color: black;</span><br><span class="line">font-size: 18px;</span><br><span class="line">&#125;</span><br><span class="line">h3 &#123;</span><br><span class="line">width: 180px;</span><br><span class="line">height: 38px;</span><br><span class="line">margin: 100px auto;</span><br><span class="line">text-align: center;</span><br><span class="line">line-height: 38px;</span><br><span class="line">background: deepskyblue;</span><br><span class="line">border-radius: 4px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li> 书籍列表页面 allbook.jsp  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;书籍列表&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span><br><span class="line">rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">&lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">&lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-4 column&quot;&gt;</span><br><span class="line">&lt;a class=&quot;btn btn-primary&quot;</span><br><span class="line">href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">&lt;table class=&quot;table table-hover table-striped&quot;&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">&lt;th&gt;书籍名字&lt;/th&gt;</span><br><span class="line">&lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">&lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">&lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?</span><br><span class="line">id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |</span><br><span class="line">&lt;a</span><br><span class="line">href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> BookController 类编写 ， 方法二：添加书籍 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/toAddBook&quot;)</span><br><span class="line">public String toAddPaper() &#123;</span><br><span class="line">return &quot;addBook&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/addBook&quot;)</span><br><span class="line">public String addPaper(Books books) &#123;</span><br><span class="line">System.out.println(books);</span><br><span class="line">bookService.addBook(books);</span><br><span class="line">return &quot;redirect:/book/allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 添加书籍页面：addBook.jsp </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span><br><span class="line">rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">&lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">&lt;small&gt;新增书籍&lt;/small&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt;</span><br><span class="line">书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li> BookController 类编写 ， 方法三：修改书籍  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/toUpdateBook&quot;)</span><br><span class="line">public String toUpdateBook(Model model, int id) &#123;</span><br><span class="line">Books books = bookService.queryBookById(id);</span><br><span class="line">System.out.println(books);</span><br><span class="line">model.addAttribute(&quot;book&quot;,books );</span><br><span class="line">return &quot;updateBook&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/updateBook&quot;)</span><br><span class="line">public String updateBook(Model model, Books book) &#123;</span><br><span class="line">System.out.println(book);</span><br><span class="line">bookService.updateBook(book);</span><br><span class="line">Books books = bookService.queryBookById(book.getBookID());</span><br><span class="line">model.addAttribute(&quot;books&quot;, books);</span><br><span class="line">return &quot;redirect:/book/allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li> 修改书籍页面 updateBook.jsp  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;修改信息&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">&lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span><br><span class="line">rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row clearfix&quot;&gt;</span><br><span class="line">&lt;div class=&quot;col-md-12 column&quot;&gt;</span><br><span class="line">&lt;div class=&quot;page-header&quot;&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">&lt;small&gt;修改信息&lt;/small&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.getBookID()&#125;&quot;/&gt;</span><br><span class="line">书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.getBookName()&#125;&quot;/&gt;</span><br><span class="line">书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.getBookCounts()&#125;&quot;/&gt;</span><br><span class="line">书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.getDetail() &#125;&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li> BookController 类编写 ， 方法四：删除书籍 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span><br><span class="line">public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123;</span><br><span class="line">bookService.deleteBookById(id);</span><br><span class="line">return &quot;redirect:/book/allBook&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置Tomcat，进行运行！ </p><p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需 要保证，不看任何东西，自己也可以完整的实现出来！ 项目结构图  </p><p><img src="https://s1.ax1x.com/2022/06/22/j9YbQJ.png" alt="1655887958255"></p><p><strong>结论：</strong></p><p>​         SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改 查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的 底线。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-04：数据处理及跳转</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-04%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-04%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%8F%8A%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-04：数据处理及跳转"><a href="#SpringMVC-04：数据处理及跳转" class="headerlink" title="SpringMVC-04：数据处理及跳转"></a>SpringMVC-04：数据处理及跳转</h1><h3 id="结果跳转方式"><a href="#结果跳转方式" class="headerlink" title="结果跳转方式"></a>结果跳转方式</h3><h4 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h4><p> 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . </p><p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">id=&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">&lt;!-- 前缀 --&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">&lt;!-- 后缀 --&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 对应的controller类  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ControllerTest1 implements Controller &#123;</span><br><span class="line">public ModelAndView handleRequest(HttpServletRequest httpServletRequest,</span><br><span class="line">HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line">//返回一个模型视图对象</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);</span><br><span class="line">mv.setViewName(&quot;test&quot;);</span><br><span class="line">return mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h4><p> 通过设置ServletAPI , 不需要视图解析器 </p><ol><li> 通过HttpServletResponse进行输出 </li><li> 通过HttpServletResponse实现重定向 </li><li> 通过HttpServletResponse实现转发 </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ResultGo &#123;</span><br><span class="line">@RequestMapping(&quot;/result/t1&quot;)</span><br><span class="line">public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;</span><br><span class="line">rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/result/t2&quot;)</span><br><span class="line">public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;</span><br><span class="line">rsp.sendRedirect(&quot;/index.jsp&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/result/t3&quot;)</span><br><span class="line">public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;</span><br><span class="line">//转发</span><br><span class="line">req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);</span><br><span class="line">req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><p> 通过SpringMVC来实现转发和重定向 - 无需视图解析器； </p><p> 测试前，需要将视图解析器注释掉 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ResultSpringMVC &#123;</span><br><span class="line">@RequestMapping(&quot;/rsm/t1&quot;)</span><br><span class="line">public String test1()&#123;</span><br><span class="line">//转发</span><br><span class="line">return &quot;/index.jsp&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/rsm/t2&quot;)</span><br><span class="line">public String test2()&#123;</span><br><span class="line">//转发二</span><br><span class="line">return &quot;forward:/index.jsp&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/rsm/t3&quot;)</span><br><span class="line">public String test3()&#123;</span><br><span class="line">//重定向</span><br><span class="line">return &quot;redirect:/index.jsp&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过SpringMVC来实现转发和重定向 - 有视图解析器； </p><p> 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 .  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ResultSpringMVC2 &#123;</span><br><span class="line">@RequestMapping(&quot;/rsm2/t1&quot;)</span><br><span class="line">public String test1()&#123;</span><br><span class="line">//转发</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/rsm2/t2&quot;)</span><br><span class="line">public String test2()&#123;</span><br><span class="line">//重定向</span><br><span class="line">return &quot;redirect:/index.jsp&quot;;</span><br><span class="line">//return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h4><ol><li><p>提交的域名称和处理方法的参数名一致 </p><p> 提交数据 : <a href="http://localhost:8080/hello?name=kuangshen">http://localhost:8080/hello?name=kuangshen</a> </p></li></ol><p>   处理方法 :  </p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello(String name)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li><p>提交的域名称和处理方法的参数名不一致 </p><p> 提交数据 : <a href="http://localhost:8080/hello?username=kuangshen">http://localhost:8080/hello?username=kuangshen</a> </p></li></ol><p>   处理方法 : </p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello(@RequestParam(&quot;username&quot;) String name)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>提交的是一个对象 </p><p> 要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p></li></ol><p>   1、实体类 </p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">//构造</span><br><span class="line">//get/set</span><br><span class="line">//tostring()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 </code></pre><p>   3、处理方法  </p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public String user(User user)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>后台输出 : User &#123; id=1, name=&#39;kuangshen&#39;, age=15 &#125; </code></pre><p>   说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 </p><h3 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h3><p> 第一种 : 通过ModelAndView </p><p>我们前面一直都是如此 . 就不过多解释  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ControllerTest1 implements Controller &#123;</span><br><span class="line">public ModelAndView handleRequest(HttpServletRequest httpServletRequest,</span><br><span class="line">HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line">//返回一个模型视图对象</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);</span><br><span class="line">mv.setViewName(&quot;test&quot;);</span><br><span class="line">return mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二种 : 通过ModelMap </p><p>ModelMap </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;</span><br><span class="line">//封装要显示到视图中的数据</span><br><span class="line">//相当于req.setAttribute(&quot;name&quot;,name);</span><br><span class="line">model.addAttribute(&quot;name&quot;,name);</span><br><span class="line">System.out.println(name);</span><br><span class="line">return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第三种 : 通过Model </p><p>Model  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/ct2/hello&quot;)</span><br><span class="line">public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;</span><br><span class="line">//封装要显示到视图中的数据</span><br><span class="line">//相当于req.setAttribute(&quot;name&quot;,name);</span><br><span class="line">model.addAttribute(&quot;msg&quot;,name);</span><br><span class="line">System.out.println(name);</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p> 就对于新手而言简单来说使用区别就是： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；</span><br><span class="line">ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</span><br><span class="line">ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</span><br></pre></td></tr></table></figure><p> 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p><p>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 </p><h4 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h4><p>尽量能使用utf-8的字符集就是用它！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-03：RestFul和控制器</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-03%EF%BC%9ARestFul%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-03%EF%BC%9ARestFul%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-03：RestFul和控制器"><a href="#SpringMVC-03：RestFul和控制器" class="headerlink" title="SpringMVC-03：RestFul和控制器"></a>SpringMVC-03：RestFul和控制器</h1><h3 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h3><ul><li> 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 </li><li> 控制器负责解析用户的请求并将其转换为一个模型。 </li><li> 在Spring MVC中一个控制器类可以包含多个方法 </li><li> 在Spring MVC中，对于Controller的配置方式有很多种 </li></ul><h4 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h4><p> Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实现该接口的类获得控制器功能</span><br><span class="line">public interface Controller &#123;</span><br><span class="line">//处理请求且返回一个模型与视图对象</span><br><span class="line">ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws</span><br><span class="line">Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>测试</strong> </p><ol><li> 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ </li></ol><ul><li> 删掉HelloController </li><li> mvc的配置文件只留下 视图解析器！ </li></ul><ol start="2"><li> 编写一个Controller类，ControllerTest1  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义控制器</span><br><span class="line">//注意点：不要导错包，实现Controller接口，重写方法；</span><br><span class="line">public class ControllerTest1 implements Controller &#123;</span><br><span class="line">public ModelAndView handleRequest(HttpServletRequest httpServletRequest,</span><br><span class="line">HttpServletResponse httpServletResponse) throws Exception &#123;</span><br><span class="line">//返回一个模型视图对象</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);</span><br><span class="line">mv.setViewName(&quot;test&quot;);</span><br><span class="line">return mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>  编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/22/j9YRLn.png" alt="1655882926231"></p><p> <strong>说明：</strong> </p><ul><li> 实现接口Controller定义控制器是较老的办法 </li><li> 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻 烦； </li></ul><h4 id="使用注解-Controller-！！！！！"><a href="#使用注解-Controller-！！！！！" class="headerlink" title="使用注解@Controller ！！！！！"></a>使用注解@Controller ！！！！！</h4><ul><li><p> @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；  </p></li><li><p> Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制 器，需要在配置文件中声明组件扫描。 </p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li> 增加一个ControllerTest2类，使用注解实现； </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//@Controller注解的类会自动添加到Spring上下文中</span><br><span class="line">@Controller</span><br><span class="line">public class ControllerTest2&#123;</span><br><span class="line">//映射访问路径</span><br><span class="line">@RequestMapping(&quot;/t2&quot;)</span><br><span class="line">public String index(Model model)&#123;</span><br><span class="line">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br><span class="line">model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);</span><br><span class="line">//返回视图位置</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 运行tomcat测试  </li></ul><p>  <img src="https://s1.ax1x.com/2022/06/22/j9Y4oV.png" alt="1655883107822"></p><p> <strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出 视图是被复用的，而控制器与视图之间是弱偶合关系。</strong>  <strong>注解方式是平时使用的最多的方式！</strong> </p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><h4 id="RequestMapping-1"><a href="#RequestMapping-1" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><ul><li><p> @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于 类上，表示类中的所有响应请求的方法都是以该地址作为父路径。  </p></li><li><p> 为了测试结论更加准确，我们可以加上一个项目名测试 myweb </p></li><li><p> 只注解在方法上面 </p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">@RequestMapping(&quot;/h1&quot;)</span><br><span class="line">public String test()&#123;</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名 / h1 </p><ul><li> 同时注解类与方法 </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/admin&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line">@RequestMapping(&quot;/h1&quot;)</span><br><span class="line">public String test()&#123;</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； </p><h4 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h4><p> Restful就是一个资源定位及资源操作的风格。<strong>不是标准也不是协议，只是一种风格</strong>。基于这个风格设计的软 件可以更简洁，更有层次，更易于实现缓存等机制。  </p><p> <strong>功能</strong> </p><p> 资源：互联网所有的事物都可以被抽象为资源 </p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 </p><p>分别对应 添加、 删除、修改、查询。 </p><p>传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><p> <a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p><p> <a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p><p> <a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST </p><p><a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST </p><p>使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！</p><p>如下：请求地址一样，但是功能可 以不同！ </p><p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET </p><p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p><p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT </p><p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE </p><p> <strong>学习测试</strong> </p><ol><li>  在新建一个类 RestFulController  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class RestFulController &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>  在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class RestFulController &#123;</span><br><span class="line">//映射访问路径</span><br><span class="line">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span><br><span class="line">public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;</span><br><span class="line">int result = p1+p2;</span><br><span class="line">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br><span class="line">model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);</span><br><span class="line">//返回视图位置</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 我们来测试请求查看下 </li></ol><p>   <img src="https://s1.ax1x.com/2022/06/22/j9YIiT.png" alt="1655883470290"></p><ol start="4"><li> 思考：使用路径变量的好处？ </li></ol><ul><li> 使路径变得更加简洁； </li><li>获得参数更加方便，框架会自动进行类型转换。 </li><li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访 问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。  </li></ul><p><img src="https://s1.ax1x.com/2022/06/22/j9YoJU.png" alt="1655883500693"></p><ol start="5"><li>我们来修改下对应的参数类型，再次测试 </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//映射访问路径</span><br><span class="line">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span><br><span class="line">public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;</span><br><span class="line">String result = p1+p2;</span><br><span class="line">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span><br><span class="line">model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);</span><br><span class="line">//返回视图位置</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/06/22/j9YTWF.png" alt="1655883547925"></p><p> <strong>使用method属性指定请求类型</strong></p><p> 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 </p><p>我们来测试一下： </p><ul><li> 增加一个方法 </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//映射访问路径,必须是POST请求</span><br><span class="line">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)</span><br><span class="line">public String index2(Model model)&#123;</span><br><span class="line">model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： </li></ul><p>  <img src="https://s1.ax1x.com/2022/06/22/j9YLLR.png" alt="1655883601523"></p><ul><li> 如果将POST修改为GET则正常了； </li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//映射访问路径,必须是Get请求</span><br><span class="line">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">public String index2(Model model)&#123;</span><br><span class="line">model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);</span><br><span class="line">return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://s1.ax1x.com/2022/06/22/j9Yqy9.png" alt="1655883637165"></p><p><strong>结论：</strong></p><p> Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 </p><p>所有的地址栏请求默认都会是 HTTP GET 类型的。 </p><p>方法级别的注解变体有如下几个：组合注解 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PatchMapping</span><br></pre></td></tr></table></figure><p> @GetMapping 是一个组合注解，平时使用的会比较多！ </p><p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-02：第一个MVC程序</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-02%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAMVC%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-02%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAMVC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-02：第一个MVC程序"><a href="#SpringMVC-02：第一个MVC程序" class="headerlink" title="SpringMVC-02：第一个MVC程序"></a>SpringMVC-02：第一个MVC程序</h1><p>根据步骤，试着搭建一个SpringMvc程序样例</p><p> <strong>配置版</strong> </p><ol><li><p> 新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ </p></li><li><p> 确定导入了SpringMVC 的依赖！ </p></li><li><p> 配置web.xml ， 注册<strong>DispatcherServlet</strong>  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/</span><br><span class="line">xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns</span><br><span class="line">.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;</span><br><span class="line">&lt;!--1.注册DispatcherServlet--&gt; </span><br><span class="line">&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; </span><br><span class="line">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; </span><br><span class="line">&lt;init-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; </span><br><span class="line">&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; </span><br><span class="line">&lt;/init-param&gt; </span><br><span class="line">&lt;!--启动级别-1--&gt; </span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;</span><br><span class="line">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; </span><br><span class="line">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; </span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写SpringMVC 的 配置文件！名称：<strong>springmvc-servlet.xml</strong> : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li> 添加 处理映射器 </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li> 添加 处理器适配器  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li> 添加 视图解析器  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;id=&quot;InternalResourceViewResolver&quot;&gt; </span><br><span class="line">&lt;!--前缀--&gt; </span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; </span><br><span class="line">&lt;!--后缀--&gt; </span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li> 、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个 ModelAndView，装数据，封视图；  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;import org.springframew</span><br><span class="line">ork.web.servlet.mvc.Controller;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;import javax.servlet.http.Http</span><br><span class="line">ServletResponse;</span><br><span class="line">//注意：这里我们先导入Controller接口</span><br><span class="line">public class HelloController implements Controller &#123;</span><br><span class="line">public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; </span><br><span class="line">//ModelAndView 模型和视图</span><br><span class="line">ModelAndView mv = new ModelAndView();</span><br><span class="line">//封装对象，放在ModelAndView中。</span><br><span class="line">Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); </span><br><span class="line">//封装要跳转的视图，放在ModelAndView中 </span><br><span class="line">mv.setViewName(&quot;hello&quot;); </span><br><span class="line">//: /WEB-INF/jsp/hello.jsp return mv; &#125; &#125;</span><br></pre></td></tr></table></figure><ol start="9"><li> 将自己的类交给SpringIOC容器，注册bean  </li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt;</span><br></pre></td></tr></table></figure><ol start="10"><li> 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； </li></ol><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></code></pre><ol start="11"><li> 配置Tomcat 启动测试！ </li></ol><pre><code>![1655881873735](https://s1.ax1x.com/2022/06/22/j9Y2ss.png)</code></pre><p> 小结：看这个估计大部分同学都能理解其中的原理了，<strong>但是我们实际开发才不会这么写</strong>，不然就疯了，还学 这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。  </p><p> <strong>注解版</strong> </p><ol><li><p> 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ </p></li><li><p> 由于Maven可能存在资源过滤的问题，我们将配置完善  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;build&gt; </span><br><span class="line">&lt;resources&gt; </span><br><span class="line">&lt;resource&gt; </span><br><span class="line">&lt;directory&gt;src/main/java&lt;/directory&gt; </span><br><span class="line">&lt;includes&gt; </span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt; </span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt; </span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt; </span><br><span class="line">&lt;/resource&gt; </span><br><span class="line"></span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;src/main/resources&lt;/directory&gt; </span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.properties&lt;/include&gt; </span><br><span class="line">&lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; </span><br><span class="line">&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">&lt;/resource&gt; </span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p> 在<strong>pom.xml文件引入相关的依赖</strong>：主要有<strong>Spring框架核心库、Spring MVC、servlet , JSTL</strong>等。我们在 父依赖中已经引入了！ </p></li><li><p><strong>配置web.xml</strong> </p><p> 注意点： </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns</span><br><span class="line">.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;</span><br><span class="line">&lt;!--1.注册servlet--&gt; </span><br><span class="line">&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; </span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--2、通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span><br><span class="line">&lt;init-param&gt; </span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt; </span><br><span class="line">&lt;!--3、启动顺序，数字越小，启动越早 --&gt; </span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;</span><br><span class="line">&lt;!--4、所有请求都会被springmvc拦截 --&gt; </span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; </span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><pre><code>/ 和 /* 的区别：&lt; url-pattern &gt; /  不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /*  会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。  </code></pre><ul><li> 注意web.xml版本问题，要最新版！ </li><li> 注册DispatcherServlet </li><li> 关联SpringMVC的配置文件 </li><li> 启动级别为1 </li><li> 映射路径为 / 【不要用/*，会404】 </li></ul><ol start="5"><li><p>添加Spring MVC配置文件  </p><p> 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容 器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体 配置信息如下：  </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvchttps://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; </span><br><span class="line">&lt;!-- 让Spring MVC不处理静态资源 --&gt; </span><br><span class="line">&lt;mvc:default-servlet-handler /&gt; </span><br><span class="line">&lt;!-- 支持mvc注解驱动在spring中一般采用@RequestMapping注解来完成映射关系 要想@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。而annotation-driven配置帮助我们自动完成上述两个实例的注入。-&gt; </span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!-- 视图解析器 --&gt; </span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;id=&quot;internalResourceViewResolver&quot;&gt; </span><br><span class="line">&lt;!-- 前缀 --&gt; </span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; </span><br><span class="line">&lt;!-- 后缀 --&gt; </span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><pre><code>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证 视图安全，因为这个目录下的文件，客户端不能直接访问。 </code></pre><ul><li> 让IOC的注解生效 </li><li> 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..  </li><li> MVC的注解驱动  </li><li> 配置视图解析器 </li></ul><ol start="6"><li><p>创建Controller </p><p> 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.controller;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/HelloController&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">//真实访问地址 : 项目名/HelloController/hello </span><br><span class="line">@RequestMapping(&quot;/hello&quot;) </span><br><span class="line">public String sayHello(Model model)&#123; </span><br><span class="line">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span><br><span class="line">model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;);</span><br><span class="line">//web-inf/jsp/hello.jsp return &quot;hello&quot;; </span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> @Controller是为了让Spring IOC容器初始化时自动扫描到； </li><li> @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射 所以访问时应该是/HelloController/hello；  </li><li> 方法中声明Model类型的参数是为了把Action中的数据带到视图中； </li><li> 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEBINF/jsp/hello.jsp。 </li></ul><ol start="7"><li><p>创建视图层 </p><p> 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带 回的信息； 可以通过EL表示取出Model中存放的值，或者对象； </p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt; </span><br><span class="line">&lt;title&gt;SpringMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li><p>配置Tomcat运行 </p><p> 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ </p></li></ol><p>   <img src="https://s1.ax1x.com/2022/06/22/j9YfZq.png" alt="1655882565640"></p><p><strong>结论：</strong></p><p> 实现步骤其实非常的简单： </p><ol><li> 新建一个web项目  </li><li> 导入相关jar包 </li><li> 编写web.xml , 注册DispatcherServlet  </li><li> 编写springmvc配置文件 </li><li>  接下来就是去创建对应的控制类 , controller </li><li> 最后完善前端视图和controller之间的对应 </li><li> 测试运行调试 </li></ol><p> 使用springMVC必须配置的三大件： </p><p>处理器映射器、处理器适配器、视图解析器 </p><p><strong>通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可， 而省去了大段的xml配置</strong> </p><p><img src="https://s1.ax1x.com/2022/06/22/j9Yhd0.png" alt="1655880990430"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC-01：什么是SpringMVC</title>
      <link href="/2022/05/09/SpringMvc/SpringMVC-01%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/"/>
      <url>/2022/05/09/SpringMvc/SpringMVC-01%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringMVC-01：什么是SpringMVC"><a href="#SpringMVC-01：什么是SpringMVC" class="headerlink" title="SpringMVC-01：什么是SpringMVC"></a>SpringMVC-01：什么是SpringMVC</h1><h3 id="1、回顾MVC"><a href="#1、回顾MVC" class="headerlink" title="1、回顾MVC"></a>1、回顾MVC</h3><h4 id="1-1、什么是MVC"><a href="#1-1、什么是MVC" class="headerlink" title="1.1、什么是MVC"></a>1.1、什么是MVC</h4><ul><li> MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 </li><li> 是将业务逻辑、数据、显示分离的方法来组织代码。 </li><li> MVC主要作用是降低了视图与业务逻辑间的双向偶合。 </li><li> MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 </li></ul><p> <strong>Model（模型）</strong>：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean 组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为 Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 </p><p> <strong>View（视图）</strong>：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 </p><p> <strong>Controller（控制器）</strong>：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数 据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 </p><p> <strong>最典型的MVC就是  JSP + servlet + javabean的模式。</strong> </p><p><img src="https://s1.ax1x.com/2022/06/22/j9YgMj.png"></p><h4 id="1-2、Model1时代"><a href="#1-2、Model1时代" class="headerlink" title="1.2、Model1时代"></a>1.2、Model1时代</h4><ul><li><p> 在web早期的开发中，通常采用的都是Model1。 </p></li><li><p> Model1中，主要分为两层，视图层和模型层。 </p></li></ul><p>  <img src="https://s1.ax1x.com/2022/06/22/j9Y6zQ.png" alt="1655880119322"></p><p> Model1优点：架构简单，比较适合小型项目开发； </p><p> Model1缺点：JSP职责不单一，职责过重，不便于维护； </p><h4 id="1-3、Model2时代"><a href="#1-3、Model2时代" class="headerlink" title="1.3、Model2时代"></a>1.3、Model2时代</h4><p> Model2把一个项目分成三部分，包括视图、控制、模型。 </p><p><img src="https://s1.ax1x.com/2022/06/22/j9YyRg.png" alt="1655880153971"></p><ol><li> 用户发请求 </li><li> Servlet接收请求数据，并调用对应的业务逻辑方法 </li><li>  业务处理完毕，返回更新后的数据给servlet  </li><li> servlet转向到JSP，由JSP来渲染页面 </li><li> 响应给前端更新后的页面  </li></ol><p> <strong>职责分析：</strong>  </p><p> <strong>Controller：控制器</strong>  </p><ol><li> 取得表单数据  </li><li> 调用业务逻辑 </li><li> 转向指定的页面  </li></ol><p> <strong>Model：模型</strong> </p><ol><li>  业务逻辑 </li><li> 保存数据的状态 </li></ol><p> <strong>View：视图</strong> </p><ol><li>显示页面 </li></ol><p><strong>结论：</strong></p><p> Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现 比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和 表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了 Model1的缺点。  </p><h4 id="1-4、回顾Servlet"><a href="#1-4、回顾Servlet" class="headerlink" title="1.4、回顾Servlet"></a>1.4、回顾Servlet</h4><ol><li> 新建一个Maven工程当做父工程！pom依赖！  </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">5.1</span><span class="number">.9</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p> 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ </p></li><li><p> 导入servlet 和 jsp 的 jar 依赖 </p></li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写一个Servlet类，用来处理用户的请求  (重写 doGet( )  、doPost( ) 方法)</li></ol>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.kuang.servlet;</span><br><span class="line">//实现Servlet接口</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws</span><br><span class="line">ServletException, IOException &#123;</span><br><span class="line">//取得参数</span><br><span class="line">String method = req.getParameter(&quot;method&quot;);</span><br><span class="line">if (method.equals(&quot;add&quot;))&#123;</span><br><span class="line">req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (method.equals(&quot;delete&quot;))&#123;</span><br><span class="line">req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//业务逻辑</span><br><span class="line">//视图跳转</span><br><span class="line">req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws</span><br><span class="line">ServletException, IOException &#123;</span><br><span class="line">doGet(req,resp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp </li></ol>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Kuangshen<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">$&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li> 在web.xml中注册Servlet </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/user<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li> 配置Tomcat，并启动测试  </li></ol><ul><li> localhost:8080/user?method=add</li><li>  localhost:8080/user?method=delete </li></ul><p> <strong>MVC框架要做哪些事情</strong> </p><ol><li> 将url映射到java类或java类的方法  </li><li> 封装用户提交的数据 .  </li><li> 处理请求–调用相关的业务处理–封装响应数据  </li><li> 将响应的数据进行渲染 . jsp / html 等表示层数据 </li></ol><p><strong>说明：</strong></p><p> <strong>常见的服务器端MVC框架</strong>有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；<strong>常见前端MVC框架</strong>：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….  </p><h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><h4 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h4><p> <strong>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</strong> </p><p>查看官方文档：<a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spri">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spri</a> ng-web </p><p>SpringMvc有什么魔力呢？</p><p> Spring MVC的特点：  </p><ol><li> 轻量级，简单易学 </li><li> 高效 , 基于请求响应的MVC框架 </li><li> 与Spring兼容性好，无缝结合 </li><li> 约定优于配置 </li><li> 功能强大：RESTful、数据验证、格式化、本地化、主题等 </li><li> 简洁灵活  </li></ol><p> Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 </p><p> DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户 可以采用<strong>基于注解形式进行开发</strong>，十分简洁；  </p><p> 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等 等……所以我们要学习 .  </p><h4 id="2-2、中心控制器"><a href="#2-2、中心控制器" class="headerlink" title="2.2、中心控制器"></a>2.2、中心控制器</h4><p> Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。 从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 </p><p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动 , 围绕一个中心Servlet分派请求及提供 其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。</strong> </p><p><img src="https://s1.ax1x.com/2022/06/22/j9Yri8.png" alt="1655880929885"></p><p> SpringMVC的原理如下图所示：  </p><pre><code>     当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器， 控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图 结果，将结果返回给中心控制器，再将结果返回给请求者。  </code></pre><p><img src="https://s1.ax1x.com/2022/06/22/j9YsJS.png" alt="1655880974212"></p><h4 id="2-3、SpringMVC执行原理"><a href="#2-3、SpringMVC执行原理" class="headerlink" title="2.3、SpringMVC执行原理"></a>2.3、SpringMVC执行原理</h4><p><img src="https://s1.ax1x.com/2022/06/22/j9Yhd0.png" alt="1655880990430"></p><p> 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线 表示需要开发者实现。  </p><p> <strong>简要分析执行流程</strong> </p><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet 接收请求并拦截请求。 </p><p> 我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a> </p><p> 如上url拆分成三部分：  </p><p> <a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a> </p></li></ol><p>   SpringMVC部署在服务器上的web站点 </p><p>   hello表示控制器 </p><p>   通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 </p><ol start="2"><li><p>  HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查 找Handler。 </p></li><li><p>  HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 </p></li><li><p> HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。  </p></li><li><p> HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 </p></li><li><p> Handler让具体的Controller执行。 </p></li><li><p> Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 </p></li><li><p> HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 </p></li><li><p> DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 </p></li><li><p> 视图解析器将解析的逻辑视图名传给DispatcherServlet。 </p></li><li><p>  DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 </p></li><li><p> 最终视图呈现给用户。 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring02：快速上手Spring</title>
      <link href="/2022/05/08/Spring/Spring02%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpring/"/>
      <url>/2022/05/08/Spring/Spring02%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BSpring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring02：快速上手Spring"><a href="#Spring02：快速上手Spring" class="headerlink" title="Spring02：快速上手Spring"></a>Spring02：快速上手Spring</h1><p>首先根据学习经验来说说，该如何快速上手Spring。</p><h2 id="HelloSpring"><a href="#HelloSpring" class="headerlink" title="HelloSpring"></a>HelloSpring</h2><blockquote><p>第一步：导入依赖（Jar包）</p></blockquote><p> 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 . [根据官网的指导]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>编写代码</p></blockquote><ol><li><p>编写一个Hello实体类</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">private <span class="title class_">String</span> name;</span><br><span class="line">public <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Hello,&quot;</span>+ name );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Spring配置文件，并命名为beans.xml</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">hello.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>思考</p></blockquote><ul><li><p> Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 </p></li><li><p> Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转  </p></li><li><p> 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由 Spring来创建的 </p></li><li><p>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .  </p><p> 依赖注入 : 就是利用set方法来进行注入的.  </p><p> IOC是一种编程思想，由主动的编程变成被动的接收 </p><p> 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . </p></li></ul><blockquote><p>修改案例一</p></blockquote><p> 我们在案例一中， 新增一个Spring配置文件beans.xml </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;OracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.impl.UserServiceImpl&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;OracleImpl&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">serviceImpl</span> <span class="operator">=</span> (UserServiceImpl) context.getBean(<span class="string">&quot;ServiceImpl&quot;</span>);</span><br><span class="line">serviceImpl.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所 谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ！</p><p><strong>IOC创建对象方式</strong></p><hr><blockquote><p>通过无参构造方法来创建</p></blockquote><ol><li><p>User.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;user无参构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>beans.xml</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//在执行getBean的时候, user已经创建好了 , 通过无参构造</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">//调用对象的方法 .</span></span><br><span class="line">user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！  </p></li></ol><blockquote><p>通过有参构造方法来创建</p></blockquote><ol><li><p>UserT.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserT</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserT</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p> beans.xml 有三种方式编写 </p></li></ol>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种根据index参数下标设置 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第二种根据参数名字设置 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- name指参数名 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure>   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第三种根据参数类型设置 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testT</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserT</span> <span class="variable">user</span> <span class="operator">=</span> (UserT) context.getBean(<span class="string">&quot;userT&quot;</span>);</span><br><span class="line">user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p> 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ </p><p><strong>Spring配置</strong></p><hr><blockquote><p>别名</p></blockquote><p> alias 设置别名 , 为bean设置别名 , 可以设置多个别名 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--设置别名：在获取<span class="title class_">Bean</span>的时候可以使用别名获取--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Bean的配置</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--bean就是java对象,由<span class="title class_">Spring</span>创建和管理--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span><br><span class="line">如果配置id,又配置了name,那么name是别名</span><br><span class="line">name可以设置多个别名,可以用逗号,分号,空格隔开</span><br><span class="line">如果不配置id和name,可以根据applicationContext.<span class="title function_">getBean</span>(.<span class="property">class</span>)获取对象;</span><br><span class="line"><span class="keyword">class</span>是bean的全限定名=包名+类名</span><br><span class="line">--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 h2,h3;h4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Import</p></blockquote><p> 团队的合作通过import来实现 .  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;&#123;path&#125;/beans.xml&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring04：自动装配</title>
      <link href="/2022/05/08/Spring/Spring04%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
      <url>/2022/05/08/Spring/Spring04%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring04：自动装配"><a href="#Spring04：自动装配" class="headerlink" title="Spring04：自动装配"></a>Spring04：自动装配</h1><blockquote><p> 自动装配说明 </p></blockquote><ul><li> 自动装配是使用spring满足bean依赖的一种方法 </li><li> spring会在应用上下文中为某个bean寻找其依赖的bean。 </li></ul><p> Spring中bean有三种装配机制，分别是： </p><ol><li> 在xml中显式配置； </li><li> 在java中显式配置； </li><li> 隐式的bean发现机制和自动装配。 【自动装配为主！】</li></ol><p> 这里我们主要讲第三种：自动化的装配bean。 </p><p> Spring的自动装配需要从两个角度来实现，或者说是两个操作： </p><ol><li>  组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； </li><li> 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； </li></ol><p> 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 <strong>推荐不使用自动装配xml配置 , 而使用注解。</strong>  </p><blockquote><p> 测试环境搭建 </p></blockquote><p>此次省略了自动装配的操作，直接使用最常用的<strong>注解注入</strong>！</p><ol><li><p> 新建一个项目</p></li><li><p> 新建两个实体类，Cat Dog 都有一个叫的方法 </p></li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>-Cat</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;miao~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>-Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;wang~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li> 新建一个用户类 User  </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 编写Spring配置文件 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dog&quot;</span> class=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;cat&quot;</span> class=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;cat&quot;</span> ref=<span class="string">&quot;cat&quot;</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;dog&quot;</span> ref=<span class="string">&quot;dog&quot;</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;str&quot;</span> value=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethodAutowire</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">user.getCat().shout();</span><br><span class="line">user.getDog().shout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">正常输出则，环境搭建成功！</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>使用注解来注入（装配）</p></blockquote><p> jdk1.5开始支持注解，spring2.5开始全面支持注解。</p><p> 准备工作：利用注解的方式注入属性。 </p><ol><li> 在spring配置文件中引入context文件头 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure><ol start="2"><li> 开启属性注解支持！ </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a><strong>@Autowired</strong></h2><ul><li> @Autowired是<strong>按类型</strong>自动转配的，不支持id匹配。 </li><li> 需要导入 spring-aop的包！ </li></ul><p> 测试： </p><ol><li> 将User类中的set方法去掉，使用@Autowired注解 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="keyword">private</span> String str;</span><br><span class="line"><span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dog;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li> 此时配置文件内容 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><p>测试，成功输出结果！ </p><p> @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存对象，不能为null。  </p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><ul><li> @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配  </li><li> @Qualifier不能单独使用。 </li></ul><p> 测试 :</p><ol><li> 配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p> 没有加Qualifier测试，直接报错 </p></li><li><p>在属性上添加Qualifier注解 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;dog2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure></li><li><p> 测试，成功输出！  </p></li></ol><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><ul><li> @Resource如有指定的name属性，先按该属性进行byName方式查找装配； </li><li> 其次再进行默认的byName方式进行装配； </li><li> 如果以上都不成功，则按byType的方式自动装配。 </li><li> 都不成功，则报异常。 </li></ul><p> <strong>实体类：</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"><span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>beans.xml</strong>  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User/&gt;</span></span></span><br></pre></td></tr></table></figure><p> <strong>测试：结果OK</strong> </p><p> <strong>配置文件2：beans.xml ， 删掉cat2</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>实体类上只保留注解</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p> <strong>结果：OK</strong> </p><p> <strong>结论：先进行byName查找，失败；再进行byType查找，成功。</strong> </p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><h3 id="Autowired与-Resource异同："><a href="#Autowired与-Resource异同：" class="headerlink" title="@Autowired与@Resource异同："></a>@Autowired与@Resource异同：</h3><ol><li> @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。  </li><li> @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false,如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 </li><li> @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认 取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属 性一旦指定，就只会按照名称进行装配。 </li></ol><p> <strong>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先 byName。</strong> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring09：声明式事务</title>
      <link href="/2022/05/08/Spring/Spring09%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/05/08/Spring/Spring09%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring09：声明式事务"><a href="#Spring09：声明式事务" class="headerlink" title="Spring09：声明式事务"></a>Spring09：声明式事务</h1><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务 !"></a>声明式事务 !</h2><blockquote><p> 回顾事务 </p></blockquote><ul><li> 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ </li><li> 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 </li></ul><p> <strong>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</strong> </p><p> <strong>事务四个属性ACID</strong>  </p><ol><li><p>原子性（atomicity） </p><p> 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 </p></li><li><p>一致性（consistency） </p><p> 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 </p></li><li><p>  隔离性（isolation） </p></li></ol><pre><code>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 </code></pre><ol start="4"><li><p>持久性（durability） </p><p> 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持 久化存储器中  </p></li></ol><blockquote><p> 测试 </p></blockquote><p> 在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户； </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个用户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line"><span class="comment">//根据id删除用户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p> mapper文件，我们故意把 deletes 写错，测试！  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">deletes from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 编写接口的实现类，在实现类中，我们去操作一波 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">//增加一些操作</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">mapper.addUser(user);</span><br><span class="line">mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">return</span> mapper.addUser(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">return</span> mapper.deleteUser(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 报错：sql异常，delete写错了 </p><p> 结果 ：插入成功！ </p><p> 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前我们都需要自己手动管理事务，十分麻烦！</p><p>但是<strong>Spring给我们提供了事务管理，我们只需要配置即可</strong>；  </p><blockquote><p> Spring中的事务管理 </p></blockquote><p> Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用 Spring的事务管理机制。Spring支持<strong>编程式事务管理和声明式的事务管理</strong>。 </p><p> <strong>编程式事务管理</strong> </p><ul><li> 将事务管理代码嵌到业务方法中来控制事务的提交和回滚  </li><li> 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 </li></ul><p> <strong>声明式事务管理</strong> </p><ul><li> 一般情况下比编程式事务好用。 </li><li> 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 </li><li> 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 </li></ul><p> 使用Spring管理事务，注意头文件的约束导入 : tx </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p> <strong>事务管理器</strong> </p><ul><li> 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。  </li><li> 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 </li></ul><p> <strong>JDBC事务</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>配置好事务管理器后我们需要去配置事务的通知</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;search*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>spring事务传播特性：</strong> </p><p> 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。<strong>spring支持7种事务传播行为</strong>： </p><ul><li> <strong>propagation_requierd：</strong>如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事 务中，这是最常见的选择。 </li><li> <strong>propagation_supports：</strong>支持当前事务，如果没有当前事务，就以非事务方法执行。 </li><li> <strong>propagation_mandatory：</strong>使用当前事务，如果没有当前事务，就抛出异常。  </li><li> <strong>propagation_required_new：</strong>新建事务，如果当前存在事务，把当前事务挂起。 </li><li> <strong>propagation_not_supported：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </li><li> <strong>propagation_never：</strong>以非事务方式执行操作，如果当前事务存在则抛出异常。 </li><li> <strong>propagation_nested：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 propagation_required类似的操作 </li></ul><p> <strong>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</strong>  </p><p> 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用 链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 </p><p> 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ </p><p> <strong>配置AOP</strong>  </p><p> 导入aop的头文件！ </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.dao.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>进行测试</strong> </p><p> <strong>删掉刚才插入的数据，再次测试！</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：至此，即可了解到了spring支持事务管理的强大！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring07：AOP就这么简单</title>
      <link href="/2022/05/08/Spring/Spring07%EF%BC%9AAOP%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
      <url>/2022/05/08/Spring/Spring07%EF%BC%9AAOP%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring07：AOP就这么简单"><a href="#Spring07：AOP就这么简单" class="headerlink" title="Spring07：AOP就这么简单"></a>Spring07：AOP就这么简单</h1><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p> 什么是AOP </p></blockquote><p> AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序 功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要 内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各 部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。  </p><p><img src="https://s1.ax1x.com/2022/05/17/OImGE4.png"></p><blockquote><p> Aop在Spring中的作用  </p></blockquote><p> 提供声明式事务；允许用户自定义切面 </p><p>以下名词需要了解下： </p><ul><li> 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注 的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. </li><li> 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 </li><li> 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 </li><li>目标（Target）：被通知对象。 </li><li>代理（Proxy）：向目标对象应用通知之后创建的对象。 </li><li>切入点（PointCut）：切面通知 执行的 “地点”的定义。 </li><li>连接点（JointPoint）：与切入点匹配的执行点。 </li></ul><p><img src="https://s1.ax1x.com/2022/05/17/OIm3bF.png"></p><p> SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:  </p><p><img src="https://s1.ax1x.com/2022/05/17/OImJUJ.png"></p><p> 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 </p><blockquote><p> 使用Spring实现Aop </p></blockquote><p> 【重点】使用AOP织入，需要导入一个依赖包！  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>第一种方式</strong> </p><p>通过 Spring API 实现 </p><p>首先编写我们的业务接口和实现类 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;增加用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line"><span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line"><span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line"><span class="comment">//Object : 目标对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println( o.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line"><span class="comment">//returnValue 返回值</span></span><br><span class="line"><span class="comment">//method被调用的方法</span></span><br><span class="line"><span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line"><span class="comment">//target 被调用的目标对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object</span></span><br><span class="line"><span class="params">target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行了&quot;</span> + target.getClass().getName()</span><br><span class="line">+<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法,&quot;</span></span><br><span class="line">+<span class="string">&quot;返回值：&quot;</span>+returnValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*</span></span></span><br><span class="line"><span class="string"><span class="tag">com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 测试 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.search();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块  </p><p> Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加 进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 </p><p> <strong>第二种方式</strong> </p><p>自定义类来实现Aop  </p><p>目标业务类不变依旧是userServiceImpl </p><p>第一步 : 写我们自己的一个切入类  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointcut</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 去spring中配置 </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种方式自定义实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*</span></span></span><br><span class="line"><span class="string"><span class="tag">com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 测试： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userService.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>第三种方式</strong> </p><p> 使用注解实现 ！！！</p><p> 第一步：编写一个注解实现的增强类  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.config;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointcut</span> &#123;</span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;签名:&quot;</span>+jp.getSignature());</span><br><span class="line"><span class="comment">//执行目标方法proceed</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> jp.proceed();</span><br><span class="line">System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">System.out.println(proceed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式:注解实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.AnnotationPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> aop:aspectj-autoproxy：说明  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">通过aop命名空间的<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>声明自动为spring容器中那些配置@aspectJ切面的bean创建代</span><br><span class="line">理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工</span><br><span class="line">作，但具体实现的细节已经被<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>隐藏起来了</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当</span><br><span class="line">配为<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">poxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>时，表示使用CGLib动态代理技术织入增强。不过</span><br><span class="line">即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring08：整合MyBatis</title>
      <link href="/2022/05/08/Spring/Spring08%EF%BC%9A%E6%95%B4%E5%90%88MyBatis/"/>
      <url>/2022/05/08/Spring/Spring08%EF%BC%9A%E6%95%B4%E5%90%88MyBatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring08：整合MyBatis"><a href="#Spring08：整合MyBatis" class="headerlink" title="Spring08：整合MyBatis"></a>Spring08：整合MyBatis</h1><blockquote><p> 步骤 </p></blockquote><p> <strong>1、导入相关jar包</strong>  </p><p> <strong>junit</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>mybatis</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>mysql-connector-java</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>spring相关</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>aspectJ AOP 织入器</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>mybatis-spring整合包 【重点】</strong>  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>配置Maven静态资源过滤问题！</strong>  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>2、编写配置文件</strong>  </p><p> <strong>3、代码实现</strong> </p><blockquote><p> MyBatis 的编写！</p></blockquote><p> <strong>编写pojo实体类</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id; <span class="comment">//id</span></span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">private</span> String pwd; <span class="comment">//密码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>实现mybatis的配置文件</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?</span></span></span><br><span class="line"><span class="string"><span class="tag">useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>UserDao接口编写</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>接口对应的Mapper映射文件</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>测试类</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line"><span class="keyword">for</span> (User user: userList)&#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> MyBatis-Spring学习  </p></blockquote><p> 引入Spring之前需要了解mybatis-spring包中的一些重要类； </p><p>官网： <a href="http://www.mybatis.org/spring/zh/index.html">http://www.mybatis.org/spring/zh/index.html</a> </p><p> 什么是 MyBatis-Spring？ </p><p> MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 </p><p> 知识基础 </p><p> 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重 要 </p><p> MyBatis-Spring 需要以下版本：  </p><p><img src="https://s1.ax1x.com/2022/05/18/OoSwUf.png"></p><p> 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 </p><p> 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean， 只需要把下面代码放在 Spring 的 XML 配置文件中：  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置 其它 Spring 数据库连接一样配置它就可以了。 </p><p> 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatisSpring 中，则使用 SqlSessionFactoryBean 来创建。  </p><p> 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以 使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 </p><p> SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对 象，它的配置方法和其它 Spring 数据库连接是一样的。  </p><p> 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基 础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。 </p><p> 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置 （），数据源（）和 MyBatis 的事务管理器（）都会被 忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环 境的值。 </p><p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代 替你代码中已经在使用的 SqlSession。 </p><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是 用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混 杂使用可能会引起数据一致性的问题。 </p><p>可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。  </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属 性，就像下面这样： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSession</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqlSession.getMapper...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 按下面这样，注入 SqlSessionTemplate： </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 整合实现一  </p></blockquote><ol><li> 引入Spring配置文件beans.xml  </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 配置数据源替换mybaits的数据源 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?</span></span></span><br><span class="line"><span class="string"><span class="tag">useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li> 配置SqlSessionFactory，关联MyBatis  </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--关联Mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/kuang/dao/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li> 注册sqlSessionTemplate，关联sqlSessionFactory；  </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--利用构造器注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li> 增加Dao接口的实现类；私有化sqlSessionTemplate  </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">//sqlSession不用我们自己创建了，Spring来管理</span></span><br><span class="line"><span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li> 注册bean实现 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li> 测试  </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li> 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> 整合实现二 </p></blockquote><p> mybatis-spring1.2.3版以上的才有这个 </p><p> 官方文档截图 : </p><p> dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要 管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 </p><p><img src="https://s1.ax1x.com/2022/05/18/OoSDPS.png"></p><p> 测试： </p><ol><li> 将我们上面写的UserDaoImpl修改一下 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line"><span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 修改bean的配置 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>总结</strong> : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还 可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring05：使用注解开发</title>
      <link href="/2022/05/08/Spring/Spring05%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/05/08/Spring/Spring05%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring05：使用注解开发"><a href="#Spring05：使用注解开发" class="headerlink" title="Spring05：使用注解开发"></a>Spring05：使用注解开发</h1><blockquote><p> 说明 </p></blockquote><p> 在spring4之后，想要使用注解形式，必须得要引入aop的包  </p><p><img src="https://s1.ax1x.com/2022/05/17/OIixSS.png"></p><p> 在配置文件当中，还得要引入一个context约束 </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> Bean的实现 </p></blockquote><p> 我们之前都是使用 <strong>bean</strong> 的标签进行<strong>bean注入</strong>，但是实际开发中，我们一般都会使用注解！  </p><ol><li> 配置扫描哪些包下的注解 </li></ol>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 在指定包下编写类，增加注解 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;秦疆&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 属性注入 </p></blockquote><p> 使用注解注入属性 1、可以不用提供set方法，直接在直接名 </p><ol><li> 可以不用提供set方法，直接在直接名上添加@value(“值”) </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 如果提供了set方法，在set方法上添加@value(“值”); </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="meta">@Value(&quot;小陈&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 衍生注解 </p></blockquote><p> 我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ </p><p> <strong>@Component</strong>三个衍生注解 [ @Component为最平常的注入方法 ]</p><p> 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 </p><ul><li><p> @Controller：web层 </p></li><li><p> @Service：service层 </p></li></ul><p>  该注解大多数 @Service( “名称” ) 在controller中调用可直接通过名称来调用。</p><ul><li> @Repository：dao层 </li></ul><p> <strong>写上这些注解，就相当于将这个类交给Spring管理装配了！</strong> </p><blockquote><p> 自动装配注解 </p></blockquote><p> 在Bean的自动装配已经讲过了，可以回顾！ </p><blockquote><p> 作用域 </p></blockquote><p> <strong>@scope</strong>  </p><ul><li> singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。  </li><li> prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p> XML与注解比较 </p><ul><li> XML可以适用任何场景 ，结构清晰，维护方便 </li><li> 注解不是自己提供的类使用不了，开发简单方便 </li></ul><p> xml与注解整合开发 ：推荐最佳实践 </p><ul><li> xml管理Bean </li><li> 注解完成属性注入 </li><li> 使用过程中， 可以不用扫描，扫描是为了类上的注解 </li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 作用： </p><ul><li> 进行注解驱动注册，从而使注解生效 </li><li> 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 </li><li> 如果不扫描包，就需要手动配置bean  </li><li> 如果不加注解驱动，则注入的值为null！ </li></ul><blockquote><p> 基于Java类进行配置 </p></blockquote><p> JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版 本， JavaConfig 已正式成为 Spring4 的核心功能 。 </p><p> 测试：  </p><ol><li> 编写一个实体类，Dog </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将这个类标注为Spring的一个组件，放到容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 新建一个config配置包，编写一个MyConfig配置类 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span></span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 测试 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) applicationContext.getBean(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li> 成功输出结果！ </li></ol><p> 导入其他配置如何做呢？  </p><ol><li> 我们再编写一个配置类！ </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 在之前的配置类中我们来选择导入这个配置类 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyConfig2.class)</span> <span class="comment">//导入合并其他配置类，类似于配置文件中的 inculde 标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些 注解的作用即可！ </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring03：依赖注入（DI）</title>
      <link href="/2022/05/08/Spring/Spring03%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/"/>
      <url>/2022/05/08/Spring/Spring03%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring03：依赖注入（DI）"><a href="#Spring03：依赖注入（DI）" class="headerlink" title="Spring03：依赖注入（DI）"></a>Spring03：依赖注入（DI）</h1><blockquote><p>概念</p></blockquote><ul><li><p>依赖注入（Dependency Injection,DI）。</p></li><li><p> 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .  </p></li><li><p>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 </p></li></ul><blockquote><p>构造器注入</p></blockquote><p>如Sping快速入手的案例</p><blockquote><p>Set注入（重点）</p></blockquote><p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没 有set方法 , 是 is . </p><p>测试pojo类 : </p><p>Address.java  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Student.java </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Address address;</span><br><span class="line"><span class="keyword">private</span> String[] books;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line"><span class="keyword">private</span> String wife;</span><br><span class="line"><span class="keyword">private</span> Properties info;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBooks</span><span class="params">(String[] books)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.books = books;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.hobbys = hobbys;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.card = card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGames</span><span class="params">(Set&lt;String&gt; games)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.games = games;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWife</span><span class="params">(String wife)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wife = wife;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(Properties info)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name=&quot;</span>+ name</span><br><span class="line">+ <span class="string">&quot;,address=&quot;</span>+ address.getAddress()</span><br><span class="line">+ <span class="string">&quot;,books=&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (String book:books)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&lt;&lt;&quot;</span>+book+<span class="string">&quot;&gt;&gt;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;\n爱好:&quot;</span>+hobbys);</span><br><span class="line">System.out.println(<span class="string">&quot;card:&quot;</span>+card);</span><br><span class="line">System.out.println(<span class="string">&quot;games:&quot;</span>+games);</span><br><span class="line">System.out.println(<span class="string">&quot;wife:&quot;</span>+wife);</span><br><span class="line">System.out.println(<span class="string">&quot;info:&quot;</span>+info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 1、常量注入 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">System.out.println(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Bean注入</p><p> 注意点：这里的值是一个引用，ref  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;addr&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重庆&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>3、数组注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;student&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、List注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">&quot;hobbys&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>爬山<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span></span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>5、Map注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;中国邮政&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456456456465456&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;建设&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1456682255511&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span></span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>6、set注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">&quot;games&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span></span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>7、Null注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">&quot;wife&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">null</span>/&gt;</span></span>&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>8、Properties注入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;property name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span></span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><blockquote><p>P命名和c命名注入</p></blockquote><p>User.java：【注意：这里没有参构造器】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、P命名空间注入：需要在头文件中加入约束文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">导入约束 : <span class="attr">xmlns</span>:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">&lt;!--<span class="title function_">P</span>(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>2、c命名空间注入：需要在头文件加入约束文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">导入约束 : <span class="attr">xmlns</span>:c=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="line">&lt;!--<span class="title function_">C</span>(构造: <span class="title class_">Constructor</span>)命名空间 , 属性依然要设置set方法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p> 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！  </p><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Bean作用域</p></blockquote><p> 在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean 就是由IoC容器初始化、装配及管理的对象 . </p><p><img src="https://s1.ax1x.com/2022/05/11/OU3TdH.png"></p><p> 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用 框架），只能用在基于web的Spring ApplicationContext环境。 </p><p> <strong>Singleton</strong>  </p><p> 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean 的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起 容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对 象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;ServiceImpl&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;cn.csdn.service.ServiceImpl&quot;</span> scope=<span class="string">&quot;singleton&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p> <strong>Prototype</strong>  </p><p> 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在 每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建 一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean 的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应 该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成 prototype，可以这样配置： </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;account&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;com.foo.DefaultAccount&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>/&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;bean id=<span class="string">&quot;account&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;com.foo.DefaultAccount&quot;</span> singleton=<span class="string">&quot;false&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p> <strong>Request</strong>  </p><p> 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求 都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;loginAction&quot;</span> <span class="keyword">class</span>=cn.<span class="property">csdn</span>.<span class="property">LoginAction</span><span class="string">&quot; scope=&quot;</span>request<span class="string">&quot;/&gt;</span></span><br></pre></td></tr></table></figure><p> 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且 该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状 态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当 处理请求结束，request作用域的bean实例将被销毁。 </p><p> <strong>Session</strong> </p><p> 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅 在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userPreferences&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> scope=<span class="string">&quot;session&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p> 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需 要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看 到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用 域内的bean也会被废弃掉。 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-01概述及IOC理论推导</title>
      <link href="/2022/05/08/Spring/Spring01%EF%BC%9A%E6%A6%82%E8%BF%B0%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/"/>
      <url>/2022/05/08/Spring/Spring01%EF%BC%9A%E6%A6%82%E8%BF%B0%E5%8F%8AIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring01：概述及IOC理论推导"><a href="#Spring01：概述及IOC理论推导" class="headerlink" title="Spring01：概述及IOC理论推导"></a>Spring01：概述及IOC理论推导</h1><blockquote><p>简介</p></blockquote><p><strong>Spring理念</strong> : 在我看来，Spring使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架的一个技术，主要的用途在于简化开发。 </p><p>官网 : <a href="http://spring.io/">http://spring.io/</a> </p><p>官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a> </p><p>GitHub : <a href="https://github.com/spring-projects">https://github.com/spring-projects</a>  </p><blockquote><p>优势</p></blockquote><ul><li>Spring是一个轻量级的、非入侵式的免费开源的框架、容器</li><li>具有控制反转IOC，面向切面AOP</li></ul><p>一句话：Spring是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器（框架）。</p><blockquote><p>组成</p></blockquote><p><img src="https://s1.ax1x.com/2022/05/08/O3755R.png"></p><p> Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定 义了创建、配置和管理 bean 的方式 . </p><p><img src="https://s1.ax1x.com/2022/05/08/O3j8eK.png"></p><p> 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块 的功能如下： </p><ul><li> <strong>核心容器：</strong>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模 式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 </li><li> <strong>Spring上下文：</strong>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括 企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 </li><li> <strong>Spring Aop：</strong> 通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框 架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事 务管理集成到应用程序中。 </li><li> <strong>Spring Dao：</strong> JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数 据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数 量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 </li><li> <strong>Spring Orm：</strong> Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。  </li><li> <strong>Spring Web模块：</strong> Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了 上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请 求参数绑定到域对象的工作。 </li><li> <strong>Spring Mvc框架：</strong> MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口， MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 </li></ul><blockquote><p>SpringBoot-SpringClound</p></blockquote><ul><li> Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; </li><li> Spring Cloud是基于Spring Boot实现的； </li><li> Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； </li><li> Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目， 但是Spring Cloud离不开Spring Boot，属于依赖的关系。  </li><li> SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习 SpringBoot。 </li></ul><p><img src="https://s1.ax1x.com/2022/05/08/O8pdq1.png"></p><blockquote><p>IOC的简介</p></blockquote><p> 想想以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者，程序不用去管怎么创建,怎么实现了它只负责提供一个接口这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现耦合性大大降低这也就是IOC的原型。</p><p><strong>本质：</strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p> <strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解， 新版本的Spring也可以零配置实现IoC。 </p><p> Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再 从Ioc容器中取出需要的对象。  </p><p><img src="https://s1.ax1x.com/2022/05/09/O8ObdO.png"></p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一 体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。  <strong>明白IOC的思想，是理解Spring的核心技巧</strong> ！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring06：静态/动态代理模式</title>
      <link href="/2022/05/08/Spring/Spring06%EF%BC%9A%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/08/Spring/Spring06%EF%BC%9A%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring06：静态-动态代理模式"><a href="#Spring06：静态-动态代理模式" class="headerlink" title="Spring06：静态/动态代理模式"></a>Spring06：静态/动态代理模式</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>为什么要学习代理模式，因为AOP的底层机制就是动态代理！ </p><p>代理模式：  </p><ul><li> 静态代理 </li><li> 动态代理 </li></ul><p> 学习aop之前 , 我们要先了解一下代理模式！ </p><p><img src="https://s1.ax1x.com/2022/05/17/OIVAHJ.png"></p><blockquote><p> 静态代理 </p></blockquote><p> 静态代理角色分析 </p><ul><li> 抽象角色 : 一般使用接口或者抽象类来实现  </li><li> 真实角色 : 被代理的角色 </li><li> 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 </li><li> 客户 : 使用代理角色来进行一些操作 . </li></ul><p> 代码实现 </p><p> <strong>Rent . java 即抽象角色</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Host . java 即真实角色</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Proxy . java 即代理角色</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理角色：中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Host host;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Host host)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.host = host;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>&#123;</span><br><span class="line">seeHouse();</span><br><span class="line">host.rent();</span><br><span class="line">fare();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收中介费</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Client . java 即客户</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户都会去找代理！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//房东要租房</span></span><br><span class="line"><span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line"><span class="comment">//中介帮助房东</span></span><br><span class="line"><span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line"><span class="comment">//你去找中介！</span></span><br><span class="line">proxy.rent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到 了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的 看待生活中发生的事情。 </p><p> <strong>静态代理的好处:</strong>  </p><ul><li> 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .  </li><li> 公共的业务由代理来完成 . 实现了业务的分工 , </li><li> 公共业务发生扩展时变得更加集中和方便 . </li></ul><hr><p><strong>静态代理的缺点:</strong>  </p><ul><li> 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 </li></ul><p> 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理  </p><blockquote><p> 静态代理再理解 </p></blockquote><p> 同学们练习完毕后，我们再来举一个例子，巩固大家的学习！ </p><p> 练习步骤： </p><ol><li> 创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色：增删改查业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 我们需要一个真实对象来完成这些增删改查操作 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实对象，完成增删改查操作的人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;更新了一个用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li> 需求来了，现在我们需要增加一个日志功能，怎么实现！ </li></ol><ul><li> 思路1 ：在实现类上增加代码 【麻烦！】 </li><li> 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ </li></ul><ol start="4"><li> 设置一个代理类来处理日志！代理角色 </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理角色，在这里面增加日志的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserServiceImpl userService)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">log(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">userService.add();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">log(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">userService.delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">log(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">userService.update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">log(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">userService.query();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 测试访问类： </li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//真实业务</span></span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="type">UserServiceProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>();</span><br><span class="line"><span class="comment">//使用代理类实现日志功能！</span></span><br><span class="line">proxy.setUserService(userService);</span><br><span class="line">proxy.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想； </p><p>我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 </p><p>聊聊AOP：纵向开发，横向开发 </p><blockquote><p> 动态代理 </p></blockquote><ul><li> 动态代理的角色和静态代理的一样 </li><li> 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 </li><li> 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 </li><li> 基于接口的动态代理—-JDK动态代理 </li><li> 基于类的动态代理–cglib </li><li> 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist </li><li> 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 </li></ul><p> JDK的动态代理需要了解两个类 </p><p> <strong>核心 : InvocationHandler 和 Proxy</strong> ， 打开JDK帮助文档看看 </p><p> 【InvocationHandler：调用处理程序】  </p><p><img src="https://s1.ax1x.com/2022/05/17/OIVVE9.png"></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Object invoke(Object proxy, 方法 method, Object[] args)；</span><br><span class="line">//参数</span><br><span class="line">//proxy - 调用该方法的代理实例</span><br><span class="line">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代</span><br><span class="line">理类继承该方法的代理接口的超级接口。</span><br><span class="line">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在</span><br><span class="line">适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span><br></pre></td></tr></table></figure><p> 【Proxy : 代理】  </p><p><img src="https://s1.ax1x.com/2022/05/17/OIVkB4.png"></p><p><img src="https://s1.ax1x.com/2022/05/17/OIVZNR.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">rent.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码实现 </p><p> 抽象角色和真实角色和之前的一样！  </p><p> <strong>Rent . java 即抽象角色</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Host . java 即真实角色</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>ProxyInvocationHandler. java 即代理角色</strong>  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Rent rent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRent</span><span class="params">(Rent rent)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.rent = rent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">rent.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line"><span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">seeHouse();</span><br><span class="line"><span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(rent, args);</span><br><span class="line">fare();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收中介费</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Client . java</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//真实角色</span></span><br><span class="line"><span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line"><span class="comment">//代理实例的调用处理程序</span></span><br><span class="line"><span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">pih.setRent(host); <span class="comment">//将真实角色放置进去！</span></span><br><span class="line"><span class="type">Rent</span> <span class="variable">proxy</span> <span class="operator">=</span> (Rent)pih.getProxy(); <span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">proxy.rent();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、 </p><blockquote><p> 深化理解 </p></blockquote><p> 我们来使用动态代理实现代理我们后面写的UserService！ </p><p> 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// proxy : 代理类</span></span><br><span class="line"><span class="comment">// method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">log(method.getName());</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String methodName)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;执行了&quot;</span>+methodName+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试！ </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//代理对象的调用处理程序</span></span><br><span class="line"><span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">pih.setTarget(userService); <span class="comment">//设置要代理的对象</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService)pih.getProxy(); <span class="comment">//动态生成代理类！</span></span><br><span class="line">proxy.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试，增删改查，查看结果！  </p><blockquote><p> 动态代理的好处 </p></blockquote><p> 静态代理有的它都有，静态代理没有的，它也有！ </p><ul><li> 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . </li><li>公共的业务由代理来完成 . 实现了业务的分工 , </li><li>公共业务发生扩展时变得更加集中和方便 . </li><li>一个动态代理 , 一般代理某一类业务 </li><li>一个动态代理可以代理多个类，代理的是接口！ </li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring的学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/04/30/SpringMvc/index/"/>
      <url>/2022/04/30/SpringMvc/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于博客搬迁的原因，该博客的笔记内容会在后续都更新上传</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
